{"ast":null,"code":"import { TransportSubject } from '@ceramicnetwork/transport-subject';\nimport { fromEvent, Subscriber } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nfunction createOriginFilter(allowedOrigin) {\n  if (!Array.isArray(allowedOrigin)) {\n    allowedOrigin = [allowedOrigin];\n  }\n\n  return function (event) {\n    return allowedOrigin.includes(event.origin);\n  };\n}\n\nfunction createMessageObservable(target, originOrFilter) {\n  var source = fromEvent(target, 'message');\n\n  if (originOrFilter == null) {\n    return source;\n  }\n\n  var messageFilter = typeof originOrFilter === 'function' ? originOrFilter : createOriginFilter(originOrFilter);\n  return source.pipe(filter(messageFilter));\n}\n\nfunction createPostMessageObserver(target) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return Subscriber.create(function (message) {\n    if (message != null) {\n      target.postMessage.apply(target, [message].concat(args));\n    }\n  });\n}\n\nfunction createPostMessageTransport(from, to, _temp) {\n  if (to === void 0) {\n    to = from;\n  }\n\n  var _ref = _temp === void 0 ? {} : _temp,\n      filter = _ref.filter,\n      _ref$postMessageArgum = _ref.postMessageArguments,\n      postMessageArguments = _ref$postMessageArgum === void 0 ? [] : _ref$postMessageArgum;\n\n  var source = createMessageObservable(from, filter);\n  var sink = createPostMessageObserver.apply(void 0, [to].concat(postMessageArguments));\n  return new TransportSubject(source, sink);\n}\n\nexport { createMessageObservable, createOriginFilter, createPostMessageObserver, createPostMessageTransport };","map":{"version":3,"sources":["../src/index.ts"],"names":["createOriginFilter","allowedOrigin","Array","event","createMessageObservable","target","originOrFilter","source","fromEvent","messageFilter","filter","createPostMessageObserver","args","message","createPostMessageTransport","from","to","postMessageArguments","sink"],"mappings":";;;;SA2CgBA,kB,CACdC,a,EAAAA;AAEA,MAAI,CAACC,KAAK,CAALA,OAAAA,CAAL,aAAKA,CAAL,EAAmC;AACjCD,IAAAA,aAAa,GAAG,CAAhBA,aAAgB,CAAhBA;AACD;;AACD,SAAO,UAAA,KAAA,EAAA;AAAA,WAAkBA,aAAa,CAAbA,QAAAA,CAAuBE,KAAK,CAA9C,MAAkBF,CAAlB;AAAP,GAAA;AACD;;SAEeG,uB,CACdC,M,EACAC,c,EAAAA;AAEA,MAAMC,MAAM,GAAGC,SAAS,CAAA,MAAA,EAAxB,SAAwB,CAAxB;;AACA,MAAIF,cAAc,IAAlB,IAAA,EAA4B;AAC1B,WAAA,MAAA;AACD;;AAED,MAAMG,aAAa,GACjB,OAAA,cAAA,KAAA,UAAA,GAAA,cAAA,GAAwDT,kBAAkB,CAD5E,cAC4E,CAD5E;AAEA,SAAOO,MAAM,CAANA,IAAAA,CAAYG,MAAM,CAAzB,aAAyB,CAAlBH,CAAP;AACD;;SAEeI,yB,CACdN,M,EAAAA;oCACGO,IAAAA,GAAAA,IAAAA,KAAAA,CAAAA,IAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAAA,CAAAA,GAAAA,CAAAA,C,EAAAA,IAAAA,GAAAA,C,EAAAA,IAAAA,GAAAA,I,EAAAA,IAAAA,E,EAAAA;AAAAA,IAAAA,IAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,GAAAA,SAAAA,CAAAA,IAAAA,CAAAA;;;AAEH,SAAO,UAAU,CAAV,MAAA,CAA+B,UAAA,OAAA,EAAA;AACpC,QAAIC,OAAO,IAAX,IAAA,EAAqB;AACnBR,MAAAA,MAAM,CAANA,WAAAA,CAAAA,KAAAA,CAAAA,MAAAA,EAAM,CAAA,OAAA,EAAA,MAAA,CAANA,IAAM,CAANA;AACD;AAHH,GAAO,CAAP;AAKD;;SAOeS,0B,CACdC,I,EACAC,E,EAAAA,K,EAAAA;MAAAA,EAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,IAAAA,EAAAA,GAAwBD,IAAxBC;;;gCACqE,E,GAAA,K;MAAnEN,MAAAA,GAAAA,IAAAA,CAAAA,M;mCAAQO,oB;MAAAA,oBAAAA,GAAAA,qBAAAA,KAAAA,KAAAA,CAAAA,GAAuB,EAAvBA,GAAuB,qB;;AAEjC,MAAMV,MAAM,GAAGH,uBAAuB,CAAA,IAAA,EAAtC,MAAsC,CAAtC;AACA,MAAMc,IAAI,GAAGP,yBAAyB,CAAzBA,KAAAA,CAAAA,KAAAA,CAAAA,EAAAA,CAAAA,EAAAA,EAAAA,MAAAA,CAAb,oBAAaA,CAAAA,CAAb;AACA,SAAO,IAAA,gBAAA,CAAA,MAAA,EAAP,IAAO,CAAP;AACD","sourcesContent":["import { TransportSubject } from '@ceramicnetwork/transport-subject'\nimport { Subscriber, fromEvent } from 'rxjs'\nimport type { Observable, Observer } from 'rxjs'\nimport { filter } from 'rxjs/operators'\n\n// Similar to the MessagePort interface\nexport interface PostMessageEventMap {\n  message: MessageEvent\n  messageerror: MessageEvent\n}\nexport interface PostMessageTarget extends EventTarget {\n  onmessage: ((this: any, ev: MessageEvent) => any) | null\n  onmessageerror: ((this: any, ev: MessageEvent) => any) | null\n  postMessage(...args: Array<any>): void\n  addEventListener<K extends keyof PostMessageEventMap>(\n    type: K,\n    listener: (this: any, ev: PostMessageEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions\n  ): void\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  ): void\n  removeEventListener<K extends keyof PostMessageEventMap>(\n    type: K,\n    listener: (this: any, ev: PostMessageEventMap[K]) => any,\n    options?: boolean | EventListenerOptions\n  ): void\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions\n  ): void\n}\n\nexport type MessageFilter = (event: MessageEvent) => boolean\n\n// Workarout for TS error about MessageEvent not being generic\nexport interface IncomingMessage<Data = any> extends MessageEvent {\n  readonly data: Data\n}\n\nexport function createOriginFilter<Event extends MessageEvent>(\n  allowedOrigin: string | Array<string>\n): (event: Event) => boolean {\n  if (!Array.isArray(allowedOrigin)) {\n    allowedOrigin = [allowedOrigin]\n  }\n  return (event: Event) => allowedOrigin.includes(event.origin)\n}\n\nexport function createMessageObservable<MessageData = any>(\n  target: PostMessageTarget,\n  originOrFilter?: string | Array<string> | MessageFilter\n): Observable<IncomingMessage<MessageData>> {\n  const source = fromEvent<MessageEvent>(target, 'message')\n  if (originOrFilter == null) {\n    return source\n  }\n\n  const messageFilter =\n    typeof originOrFilter === 'function' ? originOrFilter : createOriginFilter(originOrFilter)\n  return source.pipe(filter(messageFilter))\n}\n\nexport function createPostMessageObserver<MessageData = any>(\n  target: PostMessageTarget,\n  ...args: Array<any>\n): Observer<MessageData> {\n  return Subscriber.create<MessageData>((message) => {\n    if (message != null) {\n      target.postMessage(message, ...args)\n    }\n  })\n}\n\nexport type PostMessageTransportOptions = {\n  filter?: string | Array<string> | MessageFilter\n  postMessageArguments?: Array<any>\n}\n\nexport function createPostMessageTransport<MsgIn, MsgOut = MsgIn>(\n  from: PostMessageTarget,\n  to: PostMessageTarget = from,\n  { filter, postMessageArguments = [] }: PostMessageTransportOptions = {}\n): TransportSubject<IncomingMessage<MsgIn>, MsgOut> {\n  const source = createMessageObservable<MsgIn>(from, filter)\n  const sink = createPostMessageObserver<MsgOut>(to, ...postMessageArguments)\n  return new TransportSubject(source, sink)\n}\n"]},"metadata":{},"sourceType":"module"}