{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Keychain = exports.updateAuthEntry = exports.newAuthEntry = void 0;\n\nconst dids_1 = require(\"dids\");\n\nconst key_did_provider_ed25519_1 = require(\"key-did-provider-ed25519\");\n\nconst key_did_resolver_1 = __importDefault(require(\"key-did-resolver\"));\n\nconst keyring_1 = __importStar(require(\"./keyring\"));\n\nconst utils_1 = require(\"./utils\");\n\nfunction decryptAuthId(encrypted, keyring) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!encrypted.jwe) throw new Error('Invalid encrypted block');\n    const decrypted = yield keyring.asymDecryptJWE(encrypted.jwe, utils_1.parseJWEKids(encrypted.jwe));\n    return decrypted.id;\n  });\n}\n\nconst encrypter = new dids_1.DID({\n  resolver: key_did_resolver_1.default.getResolver()\n});\n\nfunction authSecretToDID(authSecret) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const did = new dids_1.DID({\n      provider: new key_did_provider_ed25519_1.Ed25519Provider(authSecret),\n      resolver: key_did_resolver_1.default.getResolver()\n    });\n    yield did.authenticate();\n    return did;\n  });\n}\n\nfunction newAuthEntry(keyring, threeIdDid, authId, authSecret) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const mainKid = `${threeIdDid}#${keyring.getKeyFragment(keyring_1.LATEST, true)}`;\n    const did = yield authSecretToDID(authSecret);\n    const cleartext = {\n      seed: keyring.seed\n    };\n    if (keyring.v03ID) cleartext.v03ID = keyring.v03ID;\n    const resolvedPromises = yield Promise.all([did.createDagJWE(cleartext, [did.id]), keyring.asymEncryptJWE({\n      id: authId\n    }, mainKid)]);\n    return {\n      did,\n      mapEntry: {\n        [did.id]: {\n          data: {\n            jwe: resolvedPromises[0]\n          },\n          id: {\n            jwe: resolvedPromises[1]\n          }\n        }\n      }\n    };\n  });\n}\n\nexports.newAuthEntry = newAuthEntry;\n\nfunction updateAuthEntry(keyring, authEntry, removedAuthIds, threeIdDid, authDid) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const mainKid = `${threeIdDid}#${keyring.getKeyFragment(keyring_1.LATEST, true)}`;\n    const authId = yield decryptAuthId(authEntry.id, keyring);\n    if (removedAuthIds.find(id => id === authId)) return null;\n    const jwes = yield Promise.all([encrypter.createDagJWE({\n      seed: keyring.seed\n    }, [authDid]), keyring.asymEncryptJWE({\n      id: authId\n    }, mainKid)]);\n    return {\n      data: {\n        jwe: jwes[0]\n      },\n      id: {\n        jwe: jwes[1]\n      }\n    };\n  });\n}\n\nexports.updateAuthEntry = updateAuthEntry;\n\nfunction rotateKeys(threeIdx, keyring, removedAuthIds) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const version = threeIdx.get3idVersion();\n    yield keyring.generateNewKeys(version);\n    const update3idState = keyring.get3idState();\n    const authMap = threeIdx.getAuthMap();\n    const newAuthMap = {};\n    yield Promise.all(Object.keys(authMap).map(authDid => __awaiter(this, void 0, void 0, function* () {\n      const entry = yield updateAuthEntry(keyring, authMap[authDid], removedAuthIds, threeIdx.id, authDid);\n\n      if (entry) {\n        newAuthMap[authDid] = entry;\n      }\n    })));\n    yield threeIdx.rotateKeys(update3idState, keyring.pastSeeds, newAuthMap);\n  });\n}\n\nclass Keychain {\n  constructor(_keyring, _threeIdx) {\n    this._keyring = _keyring;\n    this._threeIdx = _threeIdx;\n    this._pendingAdds = [];\n    this._pendingRms = [];\n  }\n\n  list() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.all(Object.values(this._threeIdx.getAuthMap()).map(({\n        id\n      }) => __awaiter(this, void 0, void 0, function* () {\n        return decryptAuthId(id, this._keyring);\n      })));\n    });\n  }\n\n  add(authId, authSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pendingAdds.push({\n        authId,\n        entry: yield newAuthEntry(this._keyring, this._threeIdx.id, authId, authSecret)\n      });\n    });\n  }\n\n  remove(authId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pendingRms.push(authId);\n    });\n  }\n\n  status() {\n    return {\n      clean: !(this._pendingAdds.length + this._pendingRms.length),\n      adding: this._pendingAdds.map(e => e.authId),\n      removing: this._pendingRms\n    };\n  }\n\n  commit() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._pendingAdds.length && !this._pendingRms.length) throw new Error('Nothing to commit');\n\n      if (Object.keys(this._threeIdx.getAuthMap()).length === 0) {\n        if (this._pendingRms.length) throw new Error('Can not remove non-existent auth method');\n        if (!this._pendingAdds.length) throw new Error('Can not add non-existent auth method');\n        yield this._threeIdx.createIDX((_a = this._pendingAdds.pop()) === null || _a === void 0 ? void 0 : _a.entry);\n      }\n\n      if (this._pendingRms.length) {\n        yield rotateKeys(this._threeIdx, this._keyring, this._pendingRms);\n        this._pendingRms = [];\n      }\n\n      if (this._pendingAdds.length) {\n        const entries = this._pendingAdds.map(e => e.entry);\n\n        this._pendingAdds = [];\n        yield this._threeIdx.addAuthEntries(entries);\n      }\n    });\n  }\n\n  static load(threeIdx, authSecret, makeTmpProvider) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const did = yield authSecretToDID(authSecret);\n      const authData = yield threeIdx.loadIDX(did.id);\n\n      if (authData) {\n        if (!((_a = authData.seed) === null || _a === void 0 ? void 0 : _a.jwe)) throw new Error('Unable to find auth data');\n\n        try {\n          const decrypted = yield did.decryptDagJWE(authData.seed.jwe);\n          const keyring = new keyring_1.default(new Uint8Array(decrypted.seed), decrypted.v03ID);\n          yield keyring.loadPastSeeds(authData.pastSeeds);\n          if (keyring.v03ID) yield threeIdx.create3idDoc(keyring.get3idState(true));\n          return new Keychain(keyring, threeIdx);\n        } catch (e) {\n          if (e.message === 'Failed to decrypt') throw new Error('Auth not allowed');\n          throw e;\n        }\n      }\n\n      return Keychain.create(threeIdx, makeTmpProvider);\n    });\n  }\n\n  static loadFromSeed(threeIdx, seed, did, makeTmpProvider) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyring = new keyring_1.default(seed);\n      yield threeIdx.loadAllDocs(did);\n      yield threeIdx.setDIDProvider(makeTmpProvider(keyring, did));\n      return new Keychain(keyring, threeIdx);\n    });\n  }\n\n  static create(threeIdx, makeTmpProvider, seed, v03ID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyring = new keyring_1.default(seed, v03ID);\n      const docParams = keyring.get3idState(true);\n      yield threeIdx.setDIDProvider(makeTmpProvider(keyring, docParams.metadata.controllers[0]));\n      yield threeIdx.create3idDoc(docParams);\n      if (v03ID) threeIdx.setV03ID(v03ID);\n      return new Keychain(keyring, threeIdx);\n    });\n  }\n\n}\n\nexports.Keychain = Keychain;","map":{"version":3,"sources":["../src/keychain.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Keychain = exports.updateAuthEntry = exports.newAuthEntry = void 0;\nconst dids_1 = require(\"dids\");\nconst key_did_provider_ed25519_1 = require(\"key-did-provider-ed25519\");\nconst key_did_resolver_1 = __importDefault(require(\"key-did-resolver\"));\nconst keyring_1 = __importStar(require(\"./keyring\"));\nconst utils_1 = require(\"./utils\");\nfunction decryptAuthId(encrypted, keyring) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!encrypted.jwe)\n            throw new Error('Invalid encrypted block');\n        const decrypted = yield keyring.asymDecryptJWE(encrypted.jwe, utils_1.parseJWEKids(encrypted.jwe));\n        return decrypted.id;\n    });\n}\nconst encrypter = new dids_1.DID({ resolver: key_did_resolver_1.default.getResolver() });\nfunction authSecretToDID(authSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const did = new dids_1.DID({\n            provider: new key_did_provider_ed25519_1.Ed25519Provider(authSecret),\n            resolver: key_did_resolver_1.default.getResolver(),\n        });\n        yield did.authenticate();\n        return did;\n    });\n}\nfunction newAuthEntry(keyring, threeIdDid, authId, authSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const mainKid = `${threeIdDid}#${keyring.getKeyFragment(keyring_1.LATEST, true)}`;\n        const did = yield authSecretToDID(authSecret);\n        const cleartext = { seed: keyring.seed };\n        if (keyring.v03ID)\n            cleartext.v03ID = keyring.v03ID;\n        const resolvedPromises = yield Promise.all([\n            did.createDagJWE(cleartext, [did.id]),\n            keyring.asymEncryptJWE({ id: authId }, mainKid),\n        ]);\n        return {\n            did,\n            mapEntry: {\n                [did.id]: {\n                    data: { jwe: resolvedPromises[0] },\n                    id: { jwe: resolvedPromises[1] },\n                },\n            },\n        };\n    });\n}\nexports.newAuthEntry = newAuthEntry;\nfunction updateAuthEntry(keyring, authEntry, removedAuthIds, threeIdDid, authDid) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const mainKid = `${threeIdDid}#${keyring.getKeyFragment(keyring_1.LATEST, true)}`;\n        const authId = yield decryptAuthId(authEntry.id, keyring);\n        if (removedAuthIds.find((id) => id === authId))\n            return null;\n        const jwes = yield Promise.all([\n            encrypter.createDagJWE({ seed: keyring.seed }, [authDid]),\n            keyring.asymEncryptJWE({ id: authId }, mainKid),\n        ]);\n        return {\n            data: { jwe: jwes[0] },\n            id: { jwe: jwes[1] },\n        };\n    });\n}\nexports.updateAuthEntry = updateAuthEntry;\nfunction rotateKeys(threeIdx, keyring, removedAuthIds) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const version = threeIdx.get3idVersion();\n        yield keyring.generateNewKeys(version);\n        const update3idState = keyring.get3idState();\n        const authMap = threeIdx.getAuthMap();\n        const newAuthMap = {};\n        yield Promise.all(Object.keys(authMap).map((authDid) => __awaiter(this, void 0, void 0, function* () {\n            const entry = yield updateAuthEntry(keyring, authMap[authDid], removedAuthIds, threeIdx.id, authDid);\n            if (entry) {\n                newAuthMap[authDid] = entry;\n            }\n        })));\n        yield threeIdx.rotateKeys(update3idState, keyring.pastSeeds, newAuthMap);\n    });\n}\nclass Keychain {\n    constructor(_keyring, _threeIdx) {\n        this._keyring = _keyring;\n        this._threeIdx = _threeIdx;\n        this._pendingAdds = [];\n        this._pendingRms = [];\n    }\n    list() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.all(Object.values(this._threeIdx.getAuthMap()).map(({ id }) => __awaiter(this, void 0, void 0, function* () {\n                return decryptAuthId(id, this._keyring);\n            })));\n        });\n    }\n    add(authId, authSecret) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._pendingAdds.push({\n                authId,\n                entry: yield newAuthEntry(this._keyring, this._threeIdx.id, authId, authSecret),\n            });\n        });\n    }\n    remove(authId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._pendingRms.push(authId);\n        });\n    }\n    status() {\n        return {\n            clean: !(this._pendingAdds.length + this._pendingRms.length),\n            adding: this._pendingAdds.map((e) => e.authId),\n            removing: this._pendingRms,\n        };\n    }\n    commit() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._pendingAdds.length && !this._pendingRms.length)\n                throw new Error('Nothing to commit');\n            if (Object.keys(this._threeIdx.getAuthMap()).length === 0) {\n                if (this._pendingRms.length)\n                    throw new Error('Can not remove non-existent auth method');\n                if (!this._pendingAdds.length)\n                    throw new Error('Can not add non-existent auth method');\n                yield this._threeIdx.createIDX((_a = this._pendingAdds.pop()) === null || _a === void 0 ? void 0 : _a.entry);\n            }\n            if (this._pendingRms.length) {\n                yield rotateKeys(this._threeIdx, this._keyring, this._pendingRms);\n                this._pendingRms = [];\n            }\n            if (this._pendingAdds.length) {\n                const entries = this._pendingAdds.map((e) => e.entry);\n                this._pendingAdds = [];\n                yield this._threeIdx.addAuthEntries(entries);\n            }\n        });\n    }\n    static load(threeIdx, authSecret, makeTmpProvider) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const did = yield authSecretToDID(authSecret);\n            const authData = yield threeIdx.loadIDX(did.id);\n            if (authData) {\n                if (!((_a = authData.seed) === null || _a === void 0 ? void 0 : _a.jwe))\n                    throw new Error('Unable to find auth data');\n                try {\n                    const decrypted = yield did.decryptDagJWE(authData.seed.jwe);\n                    const keyring = new keyring_1.default(new Uint8Array(decrypted.seed), decrypted.v03ID);\n                    yield keyring.loadPastSeeds(authData.pastSeeds);\n                    if (keyring.v03ID)\n                        yield threeIdx.create3idDoc(keyring.get3idState(true));\n                    return new Keychain(keyring, threeIdx);\n                }\n                catch (e) {\n                    if (e.message === 'Failed to decrypt')\n                        throw new Error('Auth not allowed');\n                    throw e;\n                }\n            }\n            return Keychain.create(threeIdx, makeTmpProvider);\n        });\n    }\n    static loadFromSeed(threeIdx, seed, did, makeTmpProvider) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyring = new keyring_1.default(seed);\n            yield threeIdx.loadAllDocs(did);\n            yield threeIdx.setDIDProvider(makeTmpProvider(keyring, did));\n            return new Keychain(keyring, threeIdx);\n        });\n    }\n    static create(threeIdx, makeTmpProvider, seed, v03ID) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyring = new keyring_1.default(seed, v03ID);\n            const docParams = keyring.get3idState(true);\n            yield threeIdx.setDIDProvider(makeTmpProvider(keyring, docParams.metadata.controllers[0]));\n            yield threeIdx.create3idDoc(docParams);\n            if (v03ID)\n                threeIdx.setV03ID(v03ID);\n            return new Keychain(keyring, threeIdx);\n        });\n    }\n}\nexports.Keychain = Keychain;\n//# sourceMappingURL=keychain.js.map"]},"metadata":{},"sourceType":"script"}