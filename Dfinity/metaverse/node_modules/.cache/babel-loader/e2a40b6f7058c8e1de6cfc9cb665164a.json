{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SELF_ORIGIN = void 0;\n\nconst store_1 = __importDefault(require(\"store\"));\n\nexports.SELF_ORIGIN = '__IDW_ORIGIN';\n\nconst storageKey = (origin, did) => {\n  if (!origin) origin = '__NULL_ORIGIN';\n  return `3id_permission_${did}_${origin}`;\n};\n\nclass Permissions {\n  constructor(getPermission) {\n    this.getPermission = getPermission;\n    this.did = null;\n\n    if (typeof this.getPermission !== 'function') {\n      throw new Error('getPermission parameter has to be a function');\n    }\n  }\n\n  setDID(did) {\n    this.did = did;\n  }\n\n  request(origin, paths = []) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.has(origin, paths)) {\n        return paths;\n      } else {\n        const given = yield this.getPermission({\n          type: 'authenticate',\n          origin,\n          payload: {\n            paths\n          }\n        });\n        const existing = this.get(origin);\n        const union = existing ? existing.concat(given ? given.filter(e => !existing.includes(e)) : []) : given;\n        this.set(origin, union);\n        return given;\n      }\n    });\n  }\n\n  has(origin, paths = []) {\n    if (origin === exports.SELF_ORIGIN) return true;\n    const currentPaths = this.get(origin);\n    return paths.reduce((acc, path) => {\n      return acc && Boolean(currentPaths === null || currentPaths === void 0 ? void 0 : currentPaths.includes(path));\n    }, Boolean(currentPaths));\n  }\n\n  get(origin) {\n    if (!this.did) throw new Error('DID not set');\n    return store_1.default.get(storageKey(origin, this.did));\n  }\n\n  set(origin, paths) {\n    if (!this.did) throw new Error('DID not set');\n    store_1.default.set(storageKey(origin, this.did), paths);\n  }\n\n}\n\nexports.default = Permissions;","map":{"version":3,"sources":["../src/permissions.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAWa,OAAA,CAAA,WAAA,GAAc,cAAd;;AAEb,MAAM,UAAU,GAAG,CAAC,MAAD,EAAiB,GAAjB,KAAgC;AACjD,MAAI,CAAC,MAAL,EAAa,MAAM,GAAG,eAAT;AACb,SAAO,kBAAkB,GAAG,IAAI,MAAM,EAAtC;AACD,CAHD;;AAKA,MAAqB,WAArB,CAAgC;AAM9B,EAAA,WAAA,CAAsB,aAAtB,EAAoD;AAA9B,SAAA,aAAA,GAAA,aAAA;AALf,SAAA,GAAA,GAAqB,IAArB;;AAML,QAAI,OAAO,KAAK,aAAZ,KAA8B,UAAlC,EAA8C;AAC5C,YAAM,IAAI,KAAJ,CAAU,8CAAV,CAAN;AACD;AACF;;AAED,EAAA,MAAM,CAAC,GAAD,EAAY;AAChB,SAAK,GAAL,GAAW,GAAX;AACD;;AASK,EAAA,OAAO,CAAC,MAAD,EAAiB,KAAA,GAAuB,EAAxC,EAA0C;;AACrD,UAAI,KAAK,GAAL,CAAS,MAAT,EAAiB,KAAjB,CAAJ,EAA6B;AAC3B,eAAO,KAAP;AACD,OAFD,MAEO;AACL,cAAM,KAAK,GAAG,MAAM,KAAK,aAAL,CAAmB;AACrC,UAAA,IAAI,EAAE,cAD+B;AAErC,UAAA,MAFqC;AAGrC,UAAA,OAAO,EAAE;AAAE,YAAA;AAAF;AAH4B,SAAnB,CAApB;AAKA,cAAM,QAAQ,GAAG,KAAK,GAAL,CAAS,MAAT,CAAjB;AACA,cAAM,KAAK,GAAG,QAAQ,GAClB,QAAQ,CAAC,MAAT,CAAgB,KAAK,GAAG,KAAK,CAAC,MAAN,CAAc,CAAD,IAAO,CAAC,QAAQ,CAAC,QAAT,CAAkB,CAAlB,CAArB,CAAH,GAAgD,EAArE,CADkB,GAElB,KAFJ;AAGA,aAAK,GAAL,CAAS,MAAT,EAAiB,KAAjB;AACA,eAAO,KAAP;AACD;AACF,K;AAAA;;AASD,EAAA,GAAG,CAAC,MAAD,EAAiB,KAAA,GAAuB,EAAxC,EAA0C;AAC3C,QAAI,MAAM,KAAK,OAAA,CAAA,WAAf,EAA4B,OAAO,IAAP;AAC5B,UAAM,YAAY,GAAG,KAAK,GAAL,CAAS,MAAT,CAArB;AACA,WAAO,KAAK,CAAC,MAAN,CAAa,CAAC,GAAD,EAAe,IAAf,KAA+B;AACjD,aAAO,GAAG,IAAI,OAAO,CAAC,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAA,YAAY,CAAE,QAAd,CAAuB,IAAvB,CAAD,CAArB;AACD,KAFM,EAEJ,OAAO,CAAC,YAAD,CAFH,CAAP;AAGD;;AAQD,EAAA,GAAG,CAAC,MAAD,EAAe;AAChB,QAAI,CAAC,KAAK,GAAV,EAAe,MAAM,IAAI,KAAJ,CAAU,aAAV,CAAN;AACf,WAAO,OAAA,CAAA,OAAA,CAAM,GAAN,CAAU,UAAU,CAAC,MAAD,EAAS,KAAK,GAAd,CAApB,CAAP;AACD;;AAQD,EAAA,GAAG,CAAC,MAAD,EAAiB,KAAjB,EAA4C;AAC7C,QAAI,CAAC,KAAK,GAAV,EAAe,MAAM,IAAI,KAAJ,CAAU,aAAV,CAAN;AACf,IAAA,OAAA,CAAA,OAAA,CAAM,GAAN,CAAU,UAAU,CAAC,MAAD,EAAS,KAAK,GAAd,CAApB,EAAwC,KAAxC;AACD;;AA5E6B;;AAAhC,OAAA,CAAA,OAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SELF_ORIGIN = void 0;\nconst store_1 = __importDefault(require(\"store\"));\nexports.SELF_ORIGIN = '__IDW_ORIGIN';\nconst storageKey = (origin, did) => {\n    if (!origin)\n        origin = '__NULL_ORIGIN';\n    return `3id_permission_${did}_${origin}`;\n};\nclass Permissions {\n    constructor(getPermission) {\n        this.getPermission = getPermission;\n        this.did = null;\n        if (typeof this.getPermission !== 'function') {\n            throw new Error('getPermission parameter has to be a function');\n        }\n    }\n    setDID(did) {\n        this.did = did;\n    }\n    request(origin, paths = []) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.has(origin, paths)) {\n                return paths;\n            }\n            else {\n                const given = yield this.getPermission({\n                    type: 'authenticate',\n                    origin,\n                    payload: { paths },\n                });\n                const existing = this.get(origin);\n                const union = existing\n                    ? existing.concat(given ? given.filter((e) => !existing.includes(e)) : [])\n                    : given;\n                this.set(origin, union);\n                return given;\n            }\n        });\n    }\n    has(origin, paths = []) {\n        if (origin === exports.SELF_ORIGIN)\n            return true;\n        const currentPaths = this.get(origin);\n        return paths.reduce((acc, path) => {\n            return acc && Boolean(currentPaths === null || currentPaths === void 0 ? void 0 : currentPaths.includes(path));\n        }, Boolean(currentPaths));\n    }\n    get(origin) {\n        if (!this.did)\n            throw new Error('DID not set');\n        return store_1.default.get(storageKey(origin, this.did));\n    }\n    set(origin, paths) {\n        if (!this.did)\n            throw new Error('DID not set');\n        store_1.default.set(storageKey(origin, this.did), paths);\n    }\n}\nexports.default = Permissions;\n//# sourceMappingURL=permissions.js.map"]},"metadata":{},"sourceType":"script"}