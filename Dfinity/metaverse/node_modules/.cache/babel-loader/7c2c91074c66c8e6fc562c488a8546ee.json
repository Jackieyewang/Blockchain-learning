{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable prefer-const */\n\n/* eslint-disable guard-for-in */\n\n\nimport { TileDocument } from '@ceramicnetwork/stream-tile';\nimport { schemas } from '../constants';\nimport { DefaultCollectionKeys, IDXAliases } from '../constants/enums';\nimport { getCollectionByKey, getCollections } from './collection';\nexport function createBookmark(idx, bookmarkToAdd) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const did = idx.id;\n    const {\n      id\n    } = yield TileDocument.create(idx.ceramic, bookmarkToAdd, {\n      schema: schemas.Bookmark,\n      controllers: [did],\n      tags: ['bookmarks']\n    });\n    console.log(id.toUrl());\n    return id.toUrl();\n  });\n}\nexport function getBookmark(idx, docID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const doc = yield idx.ceramic.loadStream(docID);\n    return doc.state.content;\n  });\n} // export async function updateBookmark(\n//   idx: IDX,\n//   bookmarkToAdd: Bookmark\n// ): Promise<string> {\n// }\n// export async function deleteBookmark(\n//   idx: IDX,\n//   bookmarkToAdd: Bookmark\n// ): Promise<string> {\n// }\n\nexport function addBookmarkToCollection(idx, params) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      bookmarkToAdd,\n      collectionKey = DefaultCollectionKeys.DEFI\n    } = params;\n    const collections = yield getCollections(idx);\n\n    if (!collections) {\n      throw new Error(`Collections are not initialized in your metaverse`);\n    }\n\n    const bookmarkID = yield createBookmark(idx, bookmarkToAdd);\n    const collectionForKey = collections[collectionKey];\n    let updatedCollection;\n    updatedCollection = !Array.isArray(collectionForKey) ? [bookmarkID] : [bookmarkID, ...collectionForKey];\n    const newCollections = Object.assign(Object.assign({}, collections), {\n      [collectionKey]: updatedCollection\n    });\n    const collectionsID = yield idx.set(IDXAliases.COLLECTIONS, newCollections);\n    return collectionsID.toUrl();\n  });\n} // export async function addBookmarksToCollection(\n//   idx: IDX,\n//   params: {\n//     bookmarkDocId: string;\n//     CollectionKey?: string;\n//   }\n// ): Promise<string> {\n// }\n\nexport function getBookmarksFromCollection(idx, collectionKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const collectionForKey = yield getCollectionByKey(idx, {\n      key: collectionKey\n    });\n\n    if (!collectionForKey) {\n      return [];\n    }\n\n    const bookmarkSet = [];\n\n    for (const bookmarkID of collectionForKey) {\n      bookmarkSet.push(yield getBookmark(idx, bookmarkID));\n    }\n\n    return bookmarkSet;\n  });\n}\nexport function getAllBookmarks(idx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const collections = yield getCollections(idx);\n\n    if (!collections) {\n      return {};\n    }\n\n    const allBookmarks = {};\n\n    for (const key in collections) {\n      const collectionForKey = collections[key];\n      const bookmarkSet = [];\n\n      for (const bookmarkID of collectionForKey) {\n        bookmarkSet.push(yield getBookmark(idx, bookmarkID));\n      }\n\n      allBookmarks[key] = bookmarkSet;\n    }\n\n    return allBookmarks;\n  });\n} // export async function removeBookmarksFromCollection(\n//   idx: IDX,\n//   params: {\n//     bookmarkDocId: string;\n//     CollectionKey?: string;\n//   }\n// ): Promise<string> {\n// }","map":{"version":3,"sources":["/Users/apple/Documents/ownership/Datadidi/test/DataDiDi/packages/idx-common/lib/esm/apis/bookmark.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","TileDocument","schemas","DefaultCollectionKeys","IDXAliases","getCollectionByKey","getCollections","createBookmark","idx","bookmarkToAdd","did","id","create","ceramic","schema","Bookmark","controllers","tags","console","log","toUrl","getBookmark","docID","doc","loadStream","state","content","addBookmarkToCollection","params","collectionKey","DEFI","collections","Error","bookmarkID","collectionForKey","updatedCollection","Array","isArray","newCollections","Object","assign","collectionsID","set","COLLECTIONS","getBookmarksFromCollection","key","bookmarkSet","push","getAllBookmarks","allBookmarks"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable prefer-const */\n/* eslint-disable guard-for-in */\nimport { TileDocument } from '@ceramicnetwork/stream-tile';\nimport { schemas } from '../constants';\nimport { DefaultCollectionKeys, IDXAliases } from '../constants/enums';\nimport { getCollectionByKey, getCollections } from './collection';\nexport function createBookmark(idx, bookmarkToAdd) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const did = idx.id;\n        const { id } = yield TileDocument.create(idx.ceramic, bookmarkToAdd, {\n            schema: schemas.Bookmark,\n            controllers: [did],\n            tags: ['bookmarks'],\n        });\n        console.log(id.toUrl());\n        return id.toUrl();\n    });\n}\nexport function getBookmark(idx, docID) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const doc = yield idx.ceramic.loadStream(docID);\n        return doc.state.content;\n    });\n}\n// export async function updateBookmark(\n//   idx: IDX,\n//   bookmarkToAdd: Bookmark\n// ): Promise<string> {\n// }\n// export async function deleteBookmark(\n//   idx: IDX,\n//   bookmarkToAdd: Bookmark\n// ): Promise<string> {\n// }\nexport function addBookmarkToCollection(idx, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { bookmarkToAdd, collectionKey = DefaultCollectionKeys.DEFI } = params;\n        const collections = yield getCollections(idx);\n        if (!collections) {\n            throw new Error(`Collections are not initialized in your metaverse`);\n        }\n        const bookmarkID = yield createBookmark(idx, bookmarkToAdd);\n        const collectionForKey = collections[collectionKey];\n        let updatedCollection;\n        updatedCollection = !Array.isArray(collectionForKey)\n            ? [bookmarkID]\n            : [bookmarkID, ...collectionForKey];\n        const newCollections = Object.assign(Object.assign({}, collections), { [collectionKey]: updatedCollection });\n        const collectionsID = yield idx.set(IDXAliases.COLLECTIONS, newCollections);\n        return collectionsID.toUrl();\n    });\n}\n// export async function addBookmarksToCollection(\n//   idx: IDX,\n//   params: {\n//     bookmarkDocId: string;\n//     CollectionKey?: string;\n//   }\n// ): Promise<string> {\n// }\nexport function getBookmarksFromCollection(idx, collectionKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const collectionForKey = yield getCollectionByKey(idx, { key: collectionKey });\n        if (!collectionForKey) {\n            return [];\n        }\n        const bookmarkSet = [];\n        for (const bookmarkID of collectionForKey) {\n            bookmarkSet.push(yield getBookmark(idx, bookmarkID));\n        }\n        return bookmarkSet;\n    });\n}\nexport function getAllBookmarks(idx) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const collections = yield getCollections(idx);\n        if (!collections) {\n            return {};\n        }\n        const allBookmarks = {};\n        for (const key in collections) {\n            const collectionForKey = collections[key];\n            const bookmarkSet = [];\n            for (const bookmarkID of collectionForKey) {\n                bookmarkSet.push(yield getBookmark(idx, bookmarkID));\n            }\n            allBookmarks[key] = bookmarkSet;\n        }\n        return allBookmarks;\n    });\n}\n// export async function removeBookmarksFromCollection(\n//   idx: IDX,\n//   params: {\n//     bookmarkDocId: string;\n//     CollectionKey?: string;\n//   }\n// ): Promise<string> {\n// }\n"]},"metadata":{},"sourceType":"module"}