{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ThreeIDX = void 0;\n\nconst stream_tile_1 = require(\"@ceramicnetwork/stream-tile\");\n\nconst http_client_1 = __importDefault(require(\"@ceramicnetwork/http-client\"));\n\nconst idx_constants_1 = require(\"@ceramicstudio/idx-constants\");\n\nconst cids_1 = __importDefault(require(\"cids\"));\n\nconst key_did_resolver_1 = __importDefault(require(\"key-did-resolver\"));\n\nconst _3id_did_resolver_1 = __importDefault(require(\"@ceramicnetwork/3id-did-resolver\"));\n\nconst did_resolver_1 = require(\"did-resolver\");\n\nconst dids_1 = require(\"dids\");\n\nconst KEYCHAIN_DEF = idx_constants_1.definitions.threeIdKeychain;\nconst IDX = 'IDX';\nconst {\n  IdentityIndex,\n  ThreeIdKeychain\n} = idx_constants_1.schemas;\n\nconst isLegacyDid = didId => {\n  try {\n    new cids_1.default(didId);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nclass ThreeIDX {\n  constructor(ceramic) {\n    this.ceramic = ceramic || new http_client_1.default();\n    this.docs = {};\n  }\n\n  setDIDProvider(provider) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyDidResolver = key_did_resolver_1.default.getResolver();\n\n      const threeIdResolver = _3id_did_resolver_1.default.getResolver(this.ceramic);\n\n      const resolver = new did_resolver_1.Resolver(Object.assign(Object.assign({}, threeIdResolver), keyDidResolver));\n      const did = new dids_1.DID({\n        provider,\n        resolver\n      });\n      yield did.authenticate();\n      yield this.ceramic.setDID(did);\n    });\n  }\n\n  setV03ID(did) {\n    this._v03ID = did;\n  }\n\n  get id() {\n    return this._v03ID || `did:3:${this.docs.threeId.id.baseID.toString()}`;\n  }\n\n  create3idDoc(docParams) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.docs.threeId = yield stream_tile_1.TileDocument.create(this.ceramic, docParams.content, docParams.metadata, {\n        anchor: false,\n        publish: false\n      });\n    });\n  }\n\n  get3idVersion() {\n    const anchorCommitIds = this.docs.threeId.anchorCommitIds;\n    const docId = anchorCommitIds[anchorCommitIds.length - 1];\n    return docId ? docId.commit.toString() : '0';\n  }\n\n  loadDoc(name, controller, family) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const stream = yield stream_tile_1.TileDocument.create(this.ceramic, null, {\n        controllers: [controller],\n        family: family,\n        deterministic: true\n      }, {\n        anchor: false,\n        publish: false\n      });\n      this.docs[name] = stream;\n      return stream;\n    });\n  }\n\n  createAuthLinkUpdate({\n    did\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const didString = did.id;\n      const tile = yield this.loadDoc(didString, didString, 'authLink');\n      yield this.ceramic.pin.add(tile.id);\n      const commit = yield tile.makeCommit({\n        did\n      }, {\n        did: this.id\n      });\n      return {\n        commit: commit,\n        docid: tile.id,\n        did: didString\n      };\n    });\n  }\n\n  applyAuthLinkUpdate({\n    docid,\n    commit,\n    did\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.docs[did].content !== this.id) {\n        yield this.ceramic.applyCommit(docid, commit);\n        yield this.docs[did].sync();\n      }\n    });\n  }\n\n  createIDX(newEntry) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const docUpdatePromise = newEntry ? this.createAuthLinkUpdate(newEntry) : Promise.resolve(null);\n      yield Promise.all([this.loadDoc(KEYCHAIN_DEF, this.id, KEYCHAIN_DEF), this.loadDoc('idx', this.id, IDX)]);\n      yield Promise.all([this.pinAllDocs(), this.updateKeychainDoc(newEntry === null || newEntry === void 0 ? void 0 : newEntry.mapEntry), this.addKeychainToIDX()]);\n      const docUpdate = yield docUpdatePromise;\n\n      if (docUpdate) {\n        yield this.applyAuthLinkUpdate(docUpdate);\n      }\n    });\n  }\n\n  loadIDX(authDid) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.loadDoc(authDid, authDid, 'authLink');\n      const {\n        did\n      } = this.docs[authDid].content;\n      if (!did) return null;\n      yield this.loadAllDocs(did);\n      const {\n        authMap,\n        pastSeeds\n      } = this.docs[KEYCHAIN_DEF].content;\n      return {\n        seed: (_a = authMap[authDid]) === null || _a === void 0 ? void 0 : _a.data,\n        pastSeeds\n      };\n    });\n  }\n\n  loadAllDocs(did) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield Promise.all([this.load3IDDoc(did), this.loadDoc(KEYCHAIN_DEF, did, KEYCHAIN_DEF), this.loadDoc('idx', did, IDX)]);\n    });\n  }\n\n  load3IDDoc(did) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const id = did.split(':')[2];\n\n      if (isLegacyDid(id)) {\n        this._v03ID = did;\n      } else {\n        this.docs.threeId = yield this.ceramic.loadStream(id);\n      }\n    });\n  }\n\n  addAuthEntries(newEntries) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const linkDocUpdatesPromise = Promise.all(newEntries.map(this.createAuthLinkUpdate.bind(this)));\n      const {\n        authMap,\n        pastSeeds\n      } = this.docs[KEYCHAIN_DEF].content;\n      const newAuthEntries = newEntries.reduce((acc, {\n        mapEntry\n      }) => Object.assign(acc, mapEntry), {});\n      Object.assign(authMap, newAuthEntries);\n      yield this.updateKeychainDoc(authMap, pastSeeds);\n      yield Promise.all((yield linkDocUpdatesPromise).map(this.applyAuthLinkUpdate.bind(this)));\n    });\n  }\n\n  getAuthMap() {\n    if (!this.docs[KEYCHAIN_DEF] || !this.docs[KEYCHAIN_DEF].content.authMap) return {};\n    return this.docs[KEYCHAIN_DEF].content.authMap;\n  }\n\n  pinAllDocs() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield Promise.all(Object.values(this.docs).map(doc => __awaiter(this, void 0, void 0, function* () {\n        yield this.ceramic.pin.add(doc.id);\n      })));\n    });\n  }\n\n  addKeychainToIDX() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const content = this.docs.idx.content;\n\n      if (!content || !content[KEYCHAIN_DEF]) {\n        const nextContent = Object.assign(content || {}, {\n          [KEYCHAIN_DEF]: this.docs[KEYCHAIN_DEF].id.toUrl()\n        });\n        const nextMetadata = this.docs.idx.metadata.schema ? undefined : {\n          schema: IdentityIndex\n        };\n        yield this.docs.idx.update(nextContent, nextMetadata);\n      }\n    });\n  }\n\n  updateKeychainDoc(authMap = {}, pastSeeds = []) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (Object.keys(authMap).length !== 0) {\n        const update = {\n          content: {\n            authMap,\n            pastSeeds\n          }\n        };\n\n        if (!this.docs[KEYCHAIN_DEF].metadata.schema) {\n          update.metadata = {\n            schema: ThreeIdKeychain\n          };\n        }\n\n        yield this.docs[KEYCHAIN_DEF].update(update.content, update.metadata);\n        yield this.docs[KEYCHAIN_DEF].sync();\n      }\n    });\n  }\n\n  rotateKeys(threeIdState, pastSeeds, authMap) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!threeIdState.content) throw new Error('Content has to be defined');\n      yield Promise.all([this.docs.threeId.update(Object.assign(Object.assign({}, this.docs.threeId.content), {\n        publicKeys: threeIdState.content.publicKeys\n      }), threeIdState.metadata), this.updateKeychainDoc(authMap, pastSeeds), this.pinAllDocs()]);\n    });\n  }\n\n}\n\nexports.ThreeIDX = ThreeIDX;","map":{"version":3,"sources":["../src/three-idx.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeIDX = void 0;\nconst stream_tile_1 = require(\"@ceramicnetwork/stream-tile\");\nconst http_client_1 = __importDefault(require(\"@ceramicnetwork/http-client\"));\nconst idx_constants_1 = require(\"@ceramicstudio/idx-constants\");\nconst cids_1 = __importDefault(require(\"cids\"));\nconst key_did_resolver_1 = __importDefault(require(\"key-did-resolver\"));\nconst _3id_did_resolver_1 = __importDefault(require(\"@ceramicnetwork/3id-did-resolver\"));\nconst did_resolver_1 = require(\"did-resolver\");\nconst dids_1 = require(\"dids\");\nconst KEYCHAIN_DEF = idx_constants_1.definitions.threeIdKeychain;\nconst IDX = 'IDX';\nconst { IdentityIndex, ThreeIdKeychain } = idx_constants_1.schemas;\nconst isLegacyDid = (didId) => {\n    try {\n        new cids_1.default(didId);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nclass ThreeIDX {\n    constructor(ceramic) {\n        this.ceramic = ceramic || new http_client_1.default();\n        this.docs = {};\n    }\n    setDIDProvider(provider) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyDidResolver = key_did_resolver_1.default.getResolver();\n            const threeIdResolver = _3id_did_resolver_1.default.getResolver(this.ceramic);\n            const resolver = new did_resolver_1.Resolver(Object.assign(Object.assign({}, threeIdResolver), keyDidResolver));\n            const did = new dids_1.DID({ provider, resolver });\n            yield did.authenticate();\n            yield this.ceramic.setDID(did);\n        });\n    }\n    setV03ID(did) {\n        this._v03ID = did;\n    }\n    get id() {\n        return this._v03ID || `did:3:${this.docs.threeId.id.baseID.toString()}`;\n    }\n    create3idDoc(docParams) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.docs.threeId = yield stream_tile_1.TileDocument.create(this.ceramic, docParams.content, docParams.metadata, {\n                anchor: false,\n                publish: false,\n            });\n        });\n    }\n    get3idVersion() {\n        const anchorCommitIds = this.docs.threeId.anchorCommitIds;\n        const docId = anchorCommitIds[anchorCommitIds.length - 1];\n        return docId ? docId.commit.toString() : '0';\n    }\n    loadDoc(name, controller, family) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stream = yield stream_tile_1.TileDocument.create(this.ceramic, null, { controllers: [controller], family: family, deterministic: true }, { anchor: false, publish: false });\n            this.docs[name] = stream;\n            return stream;\n        });\n    }\n    createAuthLinkUpdate({ did }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const didString = did.id;\n            const tile = yield this.loadDoc(didString, didString, 'authLink');\n            yield this.ceramic.pin.add(tile.id);\n            const commit = yield tile.makeCommit({ did }, { did: this.id });\n            return {\n                commit: commit,\n                docid: tile.id,\n                did: didString,\n            };\n        });\n    }\n    applyAuthLinkUpdate({ docid, commit, did }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.docs[did].content !== this.id) {\n                yield this.ceramic.applyCommit(docid, commit);\n                yield this.docs[did].sync();\n            }\n        });\n    }\n    createIDX(newEntry) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const docUpdatePromise = newEntry ? this.createAuthLinkUpdate(newEntry) : Promise.resolve(null);\n            yield Promise.all([\n                this.loadDoc(KEYCHAIN_DEF, this.id, KEYCHAIN_DEF),\n                this.loadDoc('idx', this.id, IDX),\n            ]);\n            yield Promise.all([\n                this.pinAllDocs(),\n                this.updateKeychainDoc(newEntry === null || newEntry === void 0 ? void 0 : newEntry.mapEntry),\n                this.addKeychainToIDX(),\n            ]);\n            const docUpdate = yield docUpdatePromise;\n            if (docUpdate) {\n                yield this.applyAuthLinkUpdate(docUpdate);\n            }\n        });\n    }\n    loadIDX(authDid) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.loadDoc(authDid, authDid, 'authLink');\n            const { did } = this.docs[authDid].content;\n            if (!did)\n                return null;\n            yield this.loadAllDocs(did);\n            const { authMap, pastSeeds } = this.docs[KEYCHAIN_DEF].content;\n            return {\n                seed: (_a = authMap[authDid]) === null || _a === void 0 ? void 0 : _a.data,\n                pastSeeds,\n            };\n        });\n    }\n    loadAllDocs(did) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield Promise.all([\n                this.load3IDDoc(did),\n                this.loadDoc(KEYCHAIN_DEF, did, KEYCHAIN_DEF),\n                this.loadDoc('idx', did, IDX),\n            ]);\n        });\n    }\n    load3IDDoc(did) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = did.split(':')[2];\n            if (isLegacyDid(id)) {\n                this._v03ID = did;\n            }\n            else {\n                this.docs.threeId = yield this.ceramic.loadStream(id);\n            }\n        });\n    }\n    addAuthEntries(newEntries) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const linkDocUpdatesPromise = Promise.all(newEntries.map(this.createAuthLinkUpdate.bind(this)));\n            const { authMap, pastSeeds } = this.docs[KEYCHAIN_DEF].content;\n            const newAuthEntries = newEntries.reduce((acc, { mapEntry }) => Object.assign(acc, mapEntry), {});\n            Object.assign(authMap, newAuthEntries);\n            yield this.updateKeychainDoc(authMap, pastSeeds);\n            yield Promise.all((yield linkDocUpdatesPromise).map(this.applyAuthLinkUpdate.bind(this)));\n        });\n    }\n    getAuthMap() {\n        if (!this.docs[KEYCHAIN_DEF] || !this.docs[KEYCHAIN_DEF].content.authMap)\n            return {};\n        return this.docs[KEYCHAIN_DEF].content.authMap;\n    }\n    pinAllDocs() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield Promise.all(Object.values(this.docs).map((doc) => __awaiter(this, void 0, void 0, function* () {\n                yield this.ceramic.pin.add(doc.id);\n            })));\n        });\n    }\n    addKeychainToIDX() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const content = this.docs.idx.content;\n            if (!content || !content[KEYCHAIN_DEF]) {\n                const nextContent = Object.assign(content || {}, {\n                    [KEYCHAIN_DEF]: this.docs[KEYCHAIN_DEF].id.toUrl(),\n                });\n                const nextMetadata = this.docs.idx.metadata.schema ? undefined : { schema: IdentityIndex };\n                yield this.docs.idx.update(nextContent, nextMetadata);\n            }\n        });\n    }\n    updateKeychainDoc(authMap = {}, pastSeeds = []) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (Object.keys(authMap).length !== 0) {\n                const update = { content: { authMap, pastSeeds } };\n                if (!this.docs[KEYCHAIN_DEF].metadata.schema) {\n                    update.metadata = { schema: ThreeIdKeychain };\n                }\n                yield this.docs[KEYCHAIN_DEF].update(update.content, update.metadata);\n                yield this.docs[KEYCHAIN_DEF].sync();\n            }\n        });\n    }\n    rotateKeys(threeIdState, pastSeeds, authMap) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!threeIdState.content)\n                throw new Error('Content has to be defined');\n            yield Promise.all([\n                this.docs.threeId.update(Object.assign(Object.assign({}, this.docs.threeId.content), { publicKeys: threeIdState.content.publicKeys }), threeIdState.metadata),\n                this.updateKeychainDoc(authMap, pastSeeds),\n                this.pinAllDocs(),\n            ]);\n        });\n    }\n}\nexports.ThreeIDX = ThreeIDX;\n//# sourceMappingURL=three-idx.js.map"]},"metadata":{},"sourceType":"script"}