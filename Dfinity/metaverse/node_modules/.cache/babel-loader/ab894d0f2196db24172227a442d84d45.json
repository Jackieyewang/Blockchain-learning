{"ast":null,"code":"export function Memoize(autoHashOrHashFn) {\n  return (target, propertyKey, descriptor) => {\n    if (descriptor.value != null) {\n      descriptor.value = getNewFunction(descriptor.value, autoHashOrHashFn);\n    } else if (descriptor.get != null) {\n      descriptor.get = getNewFunction(descriptor.get, autoHashOrHashFn);\n    } else {\n      throw 'Only put a Memoize() decorator on a method or get accessor.';\n    }\n  };\n}\nexport function MemoizeExpiring(duration, autoHashOrHashFn) {\n  return (target, propertyKey, descriptor) => {\n    if (descriptor.value != null) {\n      descriptor.value = getNewFunction(descriptor.value, autoHashOrHashFn, duration);\n    } else if (descriptor.get != null) {\n      descriptor.get = getNewFunction(descriptor.get, autoHashOrHashFn, duration);\n    } else {\n      throw 'Only put a Memoize() decorator on a method or get accessor.';\n    }\n  };\n}\nlet counter = 0;\n\nfunction getNewFunction(originalMethod, autoHashOrHashFn, duration = 0) {\n  const identifier = ++counter;\n  return function (...args) {\n    const propValName = `__memoized_value_${identifier}`;\n    const propMapName = `__memoized_map_${identifier}`;\n    let returnedValue;\n\n    if (autoHashOrHashFn || args.length > 0 || duration > 0) {\n      if (!this.hasOwnProperty(propMapName)) {\n        Object.defineProperty(this, propMapName, {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: new Map()\n        });\n      }\n\n      let myMap = this[propMapName];\n      let hashKey;\n\n      if (autoHashOrHashFn === true) {\n        hashKey = args.map(a => a.toString()).join('!');\n      } else if (autoHashOrHashFn) {\n        hashKey = autoHashOrHashFn.apply(this, args);\n      } else {\n        hashKey = args[0];\n      }\n\n      const timestampKey = `${hashKey}__timestamp`;\n      let isExpired = false;\n\n      if (duration > 0) {\n        if (!myMap.has(timestampKey)) {\n          isExpired = true;\n        } else {\n          let timestamp = myMap.get(timestampKey);\n          isExpired = Date.now() - timestamp > duration;\n        }\n      }\n\n      if (myMap.has(hashKey) && !isExpired) {\n        returnedValue = myMap.get(hashKey);\n      } else {\n        returnedValue = originalMethod.apply(this, args);\n        myMap.set(hashKey, returnedValue);\n\n        if (duration > 0) {\n          myMap.set(timestampKey, Date.now());\n        }\n      }\n    } else {\n      if (this.hasOwnProperty(propValName)) {\n        returnedValue = this[propValName];\n      } else {\n        returnedValue = originalMethod.apply(this, args);\n        Object.defineProperty(this, propValName, {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: returnedValue\n        });\n      }\n    }\n\n    return returnedValue;\n  };\n}","map":{"version":3,"sources":["../../src/memoize-decorator.ts"],"names":[],"mappings":"AAAA,OAAM,SAAU,OAAV,CAAkB,gBAAlB,EAAwE;AAC7E,SAAO,CAAC,MAAD,EAAiB,WAAjB,EAAsC,UAAtC,KAAkF;AAExF,QAAI,UAAU,CAAC,KAAX,IAAoB,IAAxB,EAA8B;AAC7B,MAAA,UAAU,CAAC,KAAX,GAAmB,cAAc,CAAC,UAAU,CAAC,KAAZ,EAAmB,gBAAnB,CAAjC;AACA,KAFD,MAEO,IAAI,UAAU,CAAC,GAAX,IAAkB,IAAtB,EAA4B;AAClC,MAAA,UAAU,CAAC,GAAX,GAAiB,cAAc,CAAC,UAAU,CAAC,GAAZ,EAAiB,gBAAjB,CAA/B;AACA,KAFM,MAEA;AACN,YAAM,6DAAN;AACA;AAED,GAVD;AAWA;AAED,OAAM,SAAU,eAAV,CAA0B,QAA1B,EAA4C,gBAA5C,EAAkG;AACvG,SAAO,CAAC,MAAD,EAAiB,WAAjB,EAAsC,UAAtC,KAAkF;AAExF,QAAI,UAAU,CAAC,KAAX,IAAoB,IAAxB,EAA8B;AAC7B,MAAA,UAAU,CAAC,KAAX,GAAmB,cAAc,CAAC,UAAU,CAAC,KAAZ,EAAmB,gBAAnB,EAAqC,QAArC,CAAjC;AACA,KAFD,MAEO,IAAI,UAAU,CAAC,GAAX,IAAkB,IAAtB,EAA4B;AAClC,MAAA,UAAU,CAAC,GAAX,GAAiB,cAAc,CAAC,UAAU,CAAC,GAAZ,EAAiB,gBAAjB,EAAmC,QAAnC,CAA/B;AACA,KAFM,MAEA;AACN,YAAM,6DAAN;AACA;AAED,GAVD;AAWA;AAED,IAAI,OAAO,GAAG,CAAd;;AACA,SAAS,cAAT,CAAwB,cAAxB,EAAoD,gBAApD,EAA4G,QAAA,GAAmB,CAA/H,EAAgI;AAC/H,QAAM,UAAU,GAAG,EAAE,OAArB;AAGA,SAAO,UAAU,GAAG,IAAb,EAAwB;AAC9B,UAAM,WAAW,GAAG,oBAAoB,UAAU,EAAlD;AACA,UAAM,WAAW,GAAG,kBAAkB,UAAU,EAAhD;AAEA,QAAI,aAAJ;;AAEA,QAAI,gBAAgB,IAAI,IAAI,CAAC,MAAL,GAAc,CAAlC,IAAuC,QAAQ,GAAG,CAAtD,EAAyD;AAGxD,UAAI,CAAC,KAAK,cAAL,CAAoB,WAApB,CAAL,EAAuC;AACtC,QAAA,MAAM,CAAC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;AACxC,UAAA,YAAY,EAAE,KAD0B;AAExC,UAAA,UAAU,EAAE,KAF4B;AAGxC,UAAA,QAAQ,EAAE,KAH8B;AAIxC,UAAA,KAAK,EAAE,IAAI,GAAJ;AAJiC,SAAzC;AAMA;;AACD,UAAI,KAAK,GAAkB,KAAK,WAAL,CAA3B;AAEA,UAAI,OAAJ;;AAGA,UAAI,gBAAgB,KAAK,IAAzB,EAA+B;AAC9B,QAAA,OAAO,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,IAAI,CAAC,CAAC,QAAF,EAAd,EAA4B,IAA5B,CAAiC,GAAjC,CAAV;AACA,OAFD,MAEO,IAAI,gBAAJ,EAAsB;AAC5B,QAAA,OAAO,GAAG,gBAAgB,CAAC,KAAjB,CAAuB,IAAvB,EAA6B,IAA7B,CAAV;AACA,OAFM,MAEA;AACN,QAAA,OAAO,GAAG,IAAI,CAAC,CAAD,CAAd;AACA;;AAED,YAAM,YAAY,GAAG,GAAG,OAAO,aAA/B;AACA,UAAI,SAAS,GAAY,KAAzB;;AACA,UAAI,QAAQ,GAAG,CAAf,EAAkB;AACjB,YAAI,CAAC,KAAK,CAAC,GAAN,CAAU,YAAV,CAAL,EAA8B;AAE7B,UAAA,SAAS,GAAG,IAAZ;AACA,SAHD,MAGO;AACN,cAAI,SAAS,GAAG,KAAK,CAAC,GAAN,CAAU,YAAV,CAAhB;AACA,UAAA,SAAS,GAAI,IAAI,CAAC,GAAL,KAAa,SAAd,GAA2B,QAAvC;AACA;AACD;;AAED,UAAI,KAAK,CAAC,GAAN,CAAU,OAAV,KAAsB,CAAC,SAA3B,EAAsC;AACrC,QAAA,aAAa,GAAG,KAAK,CAAC,GAAN,CAAU,OAAV,CAAhB;AACA,OAFD,MAEO;AACN,QAAA,aAAa,GAAG,cAAc,CAAC,KAAf,CAAqB,IAArB,EAA2B,IAA3B,CAAhB;AACA,QAAA,KAAK,CAAC,GAAN,CAAU,OAAV,EAAmB,aAAnB;;AACA,YAAI,QAAQ,GAAG,CAAf,EAAkB;AACjB,UAAA,KAAK,CAAC,GAAN,CAAU,YAAV,EAAwB,IAAI,CAAC,GAAL,EAAxB;AACA;AACD;AAED,KA9CD,MA8CO;AAEN,UAAI,KAAK,cAAL,CAAoB,WAApB,CAAJ,EAAsC;AACrC,QAAA,aAAa,GAAG,KAAK,WAAL,CAAhB;AACA,OAFD,MAEO;AACN,QAAA,aAAa,GAAG,cAAc,CAAC,KAAf,CAAqB,IAArB,EAA2B,IAA3B,CAAhB;AACA,QAAA,MAAM,CAAC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;AACxC,UAAA,YAAY,EAAE,KAD0B;AAExC,UAAA,UAAU,EAAE,KAF4B;AAGxC,UAAA,QAAQ,EAAE,KAH8B;AAIxC,UAAA,KAAK,EAAE;AAJiC,SAAzC;AAMA;AACD;;AAED,WAAO,aAAP;AACA,GApED;AAqEA","sourceRoot":"","sourcesContent":["export function Memoize(autoHashOrHashFn) {\n    return (target, propertyKey, descriptor) => {\n        if (descriptor.value != null) {\n            descriptor.value = getNewFunction(descriptor.value, autoHashOrHashFn);\n        }\n        else if (descriptor.get != null) {\n            descriptor.get = getNewFunction(descriptor.get, autoHashOrHashFn);\n        }\n        else {\n            throw 'Only put a Memoize() decorator on a method or get accessor.';\n        }\n    };\n}\nexport function MemoizeExpiring(duration, autoHashOrHashFn) {\n    return (target, propertyKey, descriptor) => {\n        if (descriptor.value != null) {\n            descriptor.value = getNewFunction(descriptor.value, autoHashOrHashFn, duration);\n        }\n        else if (descriptor.get != null) {\n            descriptor.get = getNewFunction(descriptor.get, autoHashOrHashFn, duration);\n        }\n        else {\n            throw 'Only put a Memoize() decorator on a method or get accessor.';\n        }\n    };\n}\nlet counter = 0;\nfunction getNewFunction(originalMethod, autoHashOrHashFn, duration = 0) {\n    const identifier = ++counter;\n    return function (...args) {\n        const propValName = `__memoized_value_${identifier}`;\n        const propMapName = `__memoized_map_${identifier}`;\n        let returnedValue;\n        if (autoHashOrHashFn || args.length > 0 || duration > 0) {\n            if (!this.hasOwnProperty(propMapName)) {\n                Object.defineProperty(this, propMapName, {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: new Map()\n                });\n            }\n            let myMap = this[propMapName];\n            let hashKey;\n            if (autoHashOrHashFn === true) {\n                hashKey = args.map(a => a.toString()).join('!');\n            }\n            else if (autoHashOrHashFn) {\n                hashKey = autoHashOrHashFn.apply(this, args);\n            }\n            else {\n                hashKey = args[0];\n            }\n            const timestampKey = `${hashKey}__timestamp`;\n            let isExpired = false;\n            if (duration > 0) {\n                if (!myMap.has(timestampKey)) {\n                    isExpired = true;\n                }\n                else {\n                    let timestamp = myMap.get(timestampKey);\n                    isExpired = (Date.now() - timestamp) > duration;\n                }\n            }\n            if (myMap.has(hashKey) && !isExpired) {\n                returnedValue = myMap.get(hashKey);\n            }\n            else {\n                returnedValue = originalMethod.apply(this, args);\n                myMap.set(hashKey, returnedValue);\n                if (duration > 0) {\n                    myMap.set(timestampKey, Date.now());\n                }\n            }\n        }\n        else {\n            if (this.hasOwnProperty(propValName)) {\n                returnedValue = this[propValName];\n            }\n            else {\n                returnedValue = originalMethod.apply(this, args);\n                Object.defineProperty(this, propValName, {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: returnedValue\n                });\n            }\n        }\n        return returnedValue;\n    };\n}\n//# sourceMappingURL=memoize-decorator.js.map"]},"metadata":{},"sourceType":"module"}