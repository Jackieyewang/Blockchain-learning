{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst pump_1 = __importDefault(require(\"pump\"));\n\nconst json_rpc_engine_1 = require(\"json-rpc-engine\");\n\nconst json_rpc_middleware_stream_1 = require(\"json-rpc-middleware-stream\");\n\nconst object_multiplex_1 = __importDefault(require(\"@metamask/object-multiplex\"));\n\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\n\nconst fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\n\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n\nconst is_stream_1 = require(\"is-stream\");\n\nconst messages_1 = __importDefault(require(\"./messages\"));\n\nconst utils_1 = require(\"./utils\");\n\nclass BaseProvider extends safe_event_emitter_1.default {\n  /**\n   * @param connectionStream - A Node.js duplex stream\n   * @param options - An options bag\n   * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.\n   * Default: metamask-provider\n   * @param options.logger - The logging API to use. Default: console\n   * @param options.maxEventListeners - The maximum number of event\n   * listeners. Default: 100\n   */\n  constructor(connectionStream, {\n    jsonRpcStreamName = 'metamask-provider',\n    logger = console,\n    maxEventListeners = 100\n  } = {}) {\n    super();\n\n    if (!is_stream_1.duplex(connectionStream)) {\n      throw new Error(messages_1.default.errors.invalidDuplexStream());\n    }\n\n    this._log = logger;\n    this.setMaxListeners(maxEventListeners); // private state\n\n    this._state = Object.assign({}, BaseProvider._defaultState); // public state\n\n    this.selectedAddress = null;\n    this.chainId = null; // bind functions (to prevent consumers from making unbound calls)\n\n    this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n    this._handleConnect = this._handleConnect.bind(this);\n    this._handleChainChanged = this._handleChainChanged.bind(this);\n    this._handleDisconnect = this._handleDisconnect.bind(this);\n    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n    this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);\n    this._rpcRequest = this._rpcRequest.bind(this);\n    this.request = this.request.bind(this); // setup connectionStream multiplexing\n\n    const mux = new object_multiplex_1.default();\n    pump_1.default(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, 'MetaMask')); // setup own event listeners\n    // EIP-1193 connect\n\n    this.on('connect', () => {\n      this._state.isConnected = true;\n    }); // setup RPC connection\n\n    this._jsonRpcConnection = json_rpc_middleware_stream_1.createStreamMiddleware();\n    pump_1.default(this._jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, 'MetaMask RpcProvider')); // handle RPC requests via dapp-side rpc engine\n\n    const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();\n    rpcEngine.push(json_rpc_engine_1.createIdRemapMiddleware());\n    rpcEngine.push(utils_1.createErrorMiddleware(this._log));\n    rpcEngine.push(this._jsonRpcConnection.middleware);\n    this._rpcEngine = rpcEngine;\n\n    this._initializeState(); // handle JSON-RPC notifications\n\n\n    this._jsonRpcConnection.events.on('notification', payload => {\n      const {\n        method,\n        params\n      } = payload;\n\n      if (method === 'metamask_accountsChanged') {\n        this._handleAccountsChanged(params);\n      } else if (method === 'metamask_unlockStateChanged') {\n        this._handleUnlockStateChanged(params);\n      } else if (method === 'metamask_chainChanged') {\n        this._handleChainChanged(params);\n      } else if (utils_1.EMITTED_NOTIFICATIONS.includes(method)) {\n        this.emit('message', {\n          type: method,\n          data: params\n        });\n      } else if (method === 'METAMASK_STREAM_FAILURE') {\n        connectionStream.destroy(new Error(messages_1.default.errors.permanentlyDisconnected()));\n      }\n    });\n  } //====================\n  // Public Methods\n  //====================\n\n  /**\n   * Returns whether the provider can process RPC requests.\n   */\n\n\n  isConnected() {\n    return this._state.isConnected;\n  }\n  /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   *\n   * @param args - The RPC request arguments.\n   * @param args.method - The RPC method name.\n   * @param args.params - The parameters for the RPC method.\n   * @returns A Promise that resolves with the result of the RPC method,\n   * or rejects if an error is encountered.\n   */\n\n\n  async request(args) {\n    if (!args || typeof args !== 'object' || Array.isArray(args)) {\n      throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n        message: messages_1.default.errors.invalidRequestArgs(),\n        data: args\n      });\n    }\n\n    const {\n      method,\n      params\n    } = args;\n\n    if (typeof method !== 'string' || method.length === 0) {\n      throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n        message: messages_1.default.errors.invalidRequestMethod(),\n        data: args\n      });\n    }\n\n    if (params !== undefined && !Array.isArray(params) && (typeof params !== 'object' || params === null)) {\n      throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n        message: messages_1.default.errors.invalidRequestParams(),\n        data: args\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rpcRequest({\n        method,\n        params\n      }, utils_1.getRpcPromiseCallback(resolve, reject));\n    });\n  } //====================\n  // Private Methods\n  //====================\n\n  /**\n   * Constructor helper.\n   * Populates initial state by calling 'metamask_getProviderState' and emits\n   * necessary events.\n   */\n\n\n  async _initializeState() {\n    try {\n      const {\n        accounts,\n        chainId,\n        isUnlocked,\n        networkVersion\n      } = await this.request({\n        method: 'metamask_getProviderState'\n      }); // indicate that we've connected, for EIP-1193 compliance\n\n      this.emit('connect', {\n        chainId\n      });\n\n      this._handleChainChanged({\n        chainId,\n        networkVersion\n      });\n\n      this._handleUnlockStateChanged({\n        accounts,\n        isUnlocked\n      });\n\n      this._handleAccountsChanged(accounts);\n    } catch (error) {\n      this._log.error('MetaMask: Failed to get initial state. Please report this bug.', error);\n    } finally {\n      this._state.initialized = true;\n      this.emit('_initialized');\n    }\n  }\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound.\n   *\n   * @param payload - The RPC request object.\n   * @param callback - The consumer's callback.\n   */\n\n\n  _rpcRequest(payload, callback) {\n    let cb = callback;\n\n    if (!Array.isArray(payload)) {\n      if (!payload.jsonrpc) {\n        payload.jsonrpc = '2.0';\n      }\n\n      if (payload.method === 'eth_accounts' || payload.method === 'eth_requestAccounts') {\n        // handle accounts changing\n        cb = (err, res) => {\n          this._handleAccountsChanged(res.result || [], payload.method === 'eth_accounts');\n\n          callback(err, res);\n        };\n      }\n\n      return this._rpcEngine.handle(payload, cb);\n    }\n\n    return this._rpcEngine.handle(payload, cb);\n  }\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * @emits MetaMaskInpageProvider#connect\n   */\n\n\n  _handleConnect(chainId) {\n    if (!this._state.isConnected) {\n      this._state.isConnected = true;\n      this.emit('connect', {\n        chainId\n      });\n\n      this._log.debug(messages_1.default.info.connected(chainId));\n    }\n  }\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * @emits MetaMaskInpageProvider#disconnect\n   */\n\n\n  _handleDisconnect(isRecoverable, errorMessage) {\n    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n      this._state.isConnected = false;\n      let error;\n\n      if (isRecoverable) {\n        error = new eth_rpc_errors_1.EthereumRpcError(1013, // Try again later\n        errorMessage || messages_1.default.errors.disconnected());\n\n        this._log.debug(error);\n      } else {\n        error = new eth_rpc_errors_1.EthereumRpcError(1011, // Internal error\n        errorMessage || messages_1.default.errors.permanentlyDisconnected());\n\n        this._log.error(error);\n\n        this.chainId = null;\n        this._state.accounts = null;\n        this.selectedAddress = null;\n        this._state.isUnlocked = false;\n        this._state.isPermanentlyDisconnected = true;\n      }\n\n      this.emit('disconnect', error);\n    }\n  }\n  /**\n   * Called when connection is lost to critical streams.\n   *\n   * @emits MetamaskInpageProvider#disconnect\n   */\n\n\n  _handleStreamDisconnect(streamName, error) {\n    utils_1.logStreamDisconnectWarning(this._log, streamName, error, this);\n\n    this._handleDisconnect(false, error ? error.message : undefined);\n  }\n  /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state.\n   * Does nothing if neither the chainId nor the networkVersion are different\n   * from existing values.\n   *\n   * @emits MetamaskInpageProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   * @param networkInfo.chainId - The latest chain ID.\n   * @param networkInfo.networkVersion - The latest network ID.\n   */\n\n\n  _handleChainChanged({\n    chainId,\n    networkVersion\n  } = {}) {\n    if (!chainId || typeof chainId !== 'string' || !chainId.startsWith('0x') || !networkVersion || typeof networkVersion !== 'string') {\n      this._log.error('MetaMask: Received invalid network parameters. Please report this bug.', {\n        chainId,\n        networkVersion\n      });\n\n      return;\n    }\n\n    if (networkVersion === 'loading') {\n      this._handleDisconnect(true);\n    } else {\n      this._handleConnect(chainId);\n\n      if (chainId !== this.chainId) {\n        this.chainId = chainId;\n\n        if (this._state.initialized) {\n          this.emit('chainChanged', this.chainId);\n        }\n      }\n    }\n  }\n  /**\n   * Called when accounts may have changed. Diffs the new accounts value with\n   * the current one, updates all state as necessary, and emits the\n   * accountsChanged event.\n   *\n   * @param accounts - The new accounts value.\n   * @param isEthAccounts - Whether the accounts value was returned by\n   * a call to eth_accounts.\n   */\n\n\n  _handleAccountsChanged(accounts, isEthAccounts = false) {\n    let _accounts = accounts;\n\n    if (!Array.isArray(accounts)) {\n      this._log.error('MetaMask: Received invalid accounts parameter. Please report this bug.', accounts);\n\n      _accounts = [];\n    }\n\n    for (const account of accounts) {\n      if (typeof account !== 'string') {\n        this._log.error('MetaMask: Received non-string account. Please report this bug.', accounts);\n\n        _accounts = [];\n        break;\n      }\n    } // emit accountsChanged if anything about the accounts array has changed\n\n\n    if (!fast_deep_equal_1.default(this._state.accounts, _accounts)) {\n      // we should always have the correct accounts even before eth_accounts\n      // returns\n      if (isEthAccounts && this._state.accounts !== null) {\n        this._log.error(`MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.`, _accounts);\n      }\n\n      this._state.accounts = _accounts; // handle selectedAddress\n\n      if (this.selectedAddress !== _accounts[0]) {\n        this.selectedAddress = _accounts[0] || null;\n      } // finally, after all state has been updated, emit the event\n\n\n      if (this._state.initialized) {\n        this.emit('accountsChanged', _accounts);\n      }\n    }\n  }\n  /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   * @param opts.accounts - The exposed accounts, if any.\n   * @param opts.isUnlocked - The latest isUnlocked value.\n   */\n\n\n  _handleUnlockStateChanged({\n    accounts,\n    isUnlocked\n  } = {}) {\n    if (typeof isUnlocked !== 'boolean') {\n      this._log.error('MetaMask: Received invalid isUnlocked parameter. Please report this bug.');\n\n      return;\n    }\n\n    if (isUnlocked !== this._state.isUnlocked) {\n      this._state.isUnlocked = isUnlocked;\n\n      this._handleAccountsChanged(accounts || []);\n    }\n  }\n\n}\n\nexports.default = BaseProvider;\nBaseProvider._defaultState = {\n  accounts: null,\n  isConnected: false,\n  isUnlocked: false,\n  initialized: false,\n  isPermanentlyDisconnected: false\n};","map":{"version":3,"sources":["../src/BaseProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pump_1 = __importDefault(require(\"pump\"));\nconst json_rpc_engine_1 = require(\"json-rpc-engine\");\nconst json_rpc_middleware_stream_1 = require(\"json-rpc-middleware-stream\");\nconst object_multiplex_1 = __importDefault(require(\"@metamask/object-multiplex\"));\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\nconst fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\nconst is_stream_1 = require(\"is-stream\");\nconst messages_1 = __importDefault(require(\"./messages\"));\nconst utils_1 = require(\"./utils\");\nclass BaseProvider extends safe_event_emitter_1.default {\n    /**\n     * @param connectionStream - A Node.js duplex stream\n     * @param options - An options bag\n     * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.\n     * Default: metamask-provider\n     * @param options.logger - The logging API to use. Default: console\n     * @param options.maxEventListeners - The maximum number of event\n     * listeners. Default: 100\n     */\n    constructor(connectionStream, { jsonRpcStreamName = 'metamask-provider', logger = console, maxEventListeners = 100, } = {}) {\n        super();\n        if (!is_stream_1.duplex(connectionStream)) {\n            throw new Error(messages_1.default.errors.invalidDuplexStream());\n        }\n        this._log = logger;\n        this.setMaxListeners(maxEventListeners);\n        // private state\n        this._state = Object.assign({}, BaseProvider._defaultState);\n        // public state\n        this.selectedAddress = null;\n        this.chainId = null;\n        // bind functions (to prevent consumers from making unbound calls)\n        this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n        this._handleConnect = this._handleConnect.bind(this);\n        this._handleChainChanged = this._handleChainChanged.bind(this);\n        this._handleDisconnect = this._handleDisconnect.bind(this);\n        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n        this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);\n        this._rpcRequest = this._rpcRequest.bind(this);\n        this.request = this.request.bind(this);\n        // setup connectionStream multiplexing\n        const mux = new object_multiplex_1.default();\n        pump_1.default(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, 'MetaMask'));\n        // setup own event listeners\n        // EIP-1193 connect\n        this.on('connect', () => {\n            this._state.isConnected = true;\n        });\n        // setup RPC connection\n        this._jsonRpcConnection = json_rpc_middleware_stream_1.createStreamMiddleware();\n        pump_1.default(this._jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, 'MetaMask RpcProvider'));\n        // handle RPC requests via dapp-side rpc engine\n        const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();\n        rpcEngine.push(json_rpc_engine_1.createIdRemapMiddleware());\n        rpcEngine.push(utils_1.createErrorMiddleware(this._log));\n        rpcEngine.push(this._jsonRpcConnection.middleware);\n        this._rpcEngine = rpcEngine;\n        this._initializeState();\n        // handle JSON-RPC notifications\n        this._jsonRpcConnection.events.on('notification', (payload) => {\n            const { method, params } = payload;\n            if (method === 'metamask_accountsChanged') {\n                this._handleAccountsChanged(params);\n            }\n            else if (method === 'metamask_unlockStateChanged') {\n                this._handleUnlockStateChanged(params);\n            }\n            else if (method === 'metamask_chainChanged') {\n                this._handleChainChanged(params);\n            }\n            else if (utils_1.EMITTED_NOTIFICATIONS.includes(method)) {\n                this.emit('message', {\n                    type: method,\n                    data: params,\n                });\n            }\n            else if (method === 'METAMASK_STREAM_FAILURE') {\n                connectionStream.destroy(new Error(messages_1.default.errors.permanentlyDisconnected()));\n            }\n        });\n    }\n    //====================\n    // Public Methods\n    //====================\n    /**\n     * Returns whether the provider can process RPC requests.\n     */\n    isConnected() {\n        return this._state.isConnected;\n    }\n    /**\n     * Submits an RPC request for the given method, with the given params.\n     * Resolves with the result of the method call, or rejects on error.\n     *\n     * @param args - The RPC request arguments.\n     * @param args.method - The RPC method name.\n     * @param args.params - The parameters for the RPC method.\n     * @returns A Promise that resolves with the result of the RPC method,\n     * or rejects if an error is encountered.\n     */\n    async request(args) {\n        if (!args || typeof args !== 'object' || Array.isArray(args)) {\n            throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n                message: messages_1.default.errors.invalidRequestArgs(),\n                data: args,\n            });\n        }\n        const { method, params } = args;\n        if (typeof method !== 'string' || method.length === 0) {\n            throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n                message: messages_1.default.errors.invalidRequestMethod(),\n                data: args,\n            });\n        }\n        if (params !== undefined &&\n            !Array.isArray(params) &&\n            (typeof params !== 'object' || params === null)) {\n            throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n                message: messages_1.default.errors.invalidRequestParams(),\n                data: args,\n            });\n        }\n        return new Promise((resolve, reject) => {\n            this._rpcRequest({ method, params }, utils_1.getRpcPromiseCallback(resolve, reject));\n        });\n    }\n    //====================\n    // Private Methods\n    //====================\n    /**\n     * Constructor helper.\n     * Populates initial state by calling 'metamask_getProviderState' and emits\n     * necessary events.\n     */\n    async _initializeState() {\n        try {\n            const { accounts, chainId, isUnlocked, networkVersion, } = (await this.request({\n                method: 'metamask_getProviderState',\n            }));\n            // indicate that we've connected, for EIP-1193 compliance\n            this.emit('connect', { chainId });\n            this._handleChainChanged({ chainId, networkVersion });\n            this._handleUnlockStateChanged({ accounts, isUnlocked });\n            this._handleAccountsChanged(accounts);\n        }\n        catch (error) {\n            this._log.error('MetaMask: Failed to get initial state. Please report this bug.', error);\n        }\n        finally {\n            this._state.initialized = true;\n            this.emit('_initialized');\n        }\n    }\n    /**\n     * Internal RPC method. Forwards requests to background via the RPC engine.\n     * Also remap ids inbound and outbound.\n     *\n     * @param payload - The RPC request object.\n     * @param callback - The consumer's callback.\n     */\n    _rpcRequest(payload, callback) {\n        let cb = callback;\n        if (!Array.isArray(payload)) {\n            if (!payload.jsonrpc) {\n                payload.jsonrpc = '2.0';\n            }\n            if (payload.method === 'eth_accounts' ||\n                payload.method === 'eth_requestAccounts') {\n                // handle accounts changing\n                cb = (err, res) => {\n                    this._handleAccountsChanged(res.result || [], payload.method === 'eth_accounts');\n                    callback(err, res);\n                };\n            }\n            return this._rpcEngine.handle(payload, cb);\n        }\n        return this._rpcEngine.handle(payload, cb);\n    }\n    /**\n     * When the provider becomes connected, updates internal state and emits\n     * required events. Idempotent.\n     *\n     * @param chainId - The ID of the newly connected chain.\n     * @emits MetaMaskInpageProvider#connect\n     */\n    _handleConnect(chainId) {\n        if (!this._state.isConnected) {\n            this._state.isConnected = true;\n            this.emit('connect', { chainId });\n            this._log.debug(messages_1.default.info.connected(chainId));\n        }\n    }\n    /**\n     * When the provider becomes disconnected, updates internal state and emits\n     * required events. Idempotent with respect to the isRecoverable parameter.\n     *\n     * Error codes per the CloseEvent status codes as required by EIP-1193:\n     * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n     *\n     * @param isRecoverable - Whether the disconnection is recoverable.\n     * @param errorMessage - A custom error message.\n     * @emits MetaMaskInpageProvider#disconnect\n     */\n    _handleDisconnect(isRecoverable, errorMessage) {\n        if (this._state.isConnected ||\n            (!this._state.isPermanentlyDisconnected && !isRecoverable)) {\n            this._state.isConnected = false;\n            let error;\n            if (isRecoverable) {\n                error = new eth_rpc_errors_1.EthereumRpcError(1013, // Try again later\n                errorMessage || messages_1.default.errors.disconnected());\n                this._log.debug(error);\n            }\n            else {\n                error = new eth_rpc_errors_1.EthereumRpcError(1011, // Internal error\n                errorMessage || messages_1.default.errors.permanentlyDisconnected());\n                this._log.error(error);\n                this.chainId = null;\n                this._state.accounts = null;\n                this.selectedAddress = null;\n                this._state.isUnlocked = false;\n                this._state.isPermanentlyDisconnected = true;\n            }\n            this.emit('disconnect', error);\n        }\n    }\n    /**\n     * Called when connection is lost to critical streams.\n     *\n     * @emits MetamaskInpageProvider#disconnect\n     */\n    _handleStreamDisconnect(streamName, error) {\n        utils_1.logStreamDisconnectWarning(this._log, streamName, error, this);\n        this._handleDisconnect(false, error ? error.message : undefined);\n    }\n    /**\n     * Upon receipt of a new chainId and networkVersion, emits corresponding\n     * events and sets relevant public state.\n     * Does nothing if neither the chainId nor the networkVersion are different\n     * from existing values.\n     *\n     * @emits MetamaskInpageProvider#chainChanged\n     * @param networkInfo - An object with network info.\n     * @param networkInfo.chainId - The latest chain ID.\n     * @param networkInfo.networkVersion - The latest network ID.\n     */\n    _handleChainChanged({ chainId, networkVersion, } = {}) {\n        if (!chainId ||\n            typeof chainId !== 'string' ||\n            !chainId.startsWith('0x') ||\n            !networkVersion ||\n            typeof networkVersion !== 'string') {\n            this._log.error('MetaMask: Received invalid network parameters. Please report this bug.', { chainId, networkVersion });\n            return;\n        }\n        if (networkVersion === 'loading') {\n            this._handleDisconnect(true);\n        }\n        else {\n            this._handleConnect(chainId);\n            if (chainId !== this.chainId) {\n                this.chainId = chainId;\n                if (this._state.initialized) {\n                    this.emit('chainChanged', this.chainId);\n                }\n            }\n        }\n    }\n    /**\n     * Called when accounts may have changed. Diffs the new accounts value with\n     * the current one, updates all state as necessary, and emits the\n     * accountsChanged event.\n     *\n     * @param accounts - The new accounts value.\n     * @param isEthAccounts - Whether the accounts value was returned by\n     * a call to eth_accounts.\n     */\n    _handleAccountsChanged(accounts, isEthAccounts = false) {\n        let _accounts = accounts;\n        if (!Array.isArray(accounts)) {\n            this._log.error('MetaMask: Received invalid accounts parameter. Please report this bug.', accounts);\n            _accounts = [];\n        }\n        for (const account of accounts) {\n            if (typeof account !== 'string') {\n                this._log.error('MetaMask: Received non-string account. Please report this bug.', accounts);\n                _accounts = [];\n                break;\n            }\n        }\n        // emit accountsChanged if anything about the accounts array has changed\n        if (!fast_deep_equal_1.default(this._state.accounts, _accounts)) {\n            // we should always have the correct accounts even before eth_accounts\n            // returns\n            if (isEthAccounts && this._state.accounts !== null) {\n                this._log.error(`MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.`, _accounts);\n            }\n            this._state.accounts = _accounts;\n            // handle selectedAddress\n            if (this.selectedAddress !== _accounts[0]) {\n                this.selectedAddress = _accounts[0] || null;\n            }\n            // finally, after all state has been updated, emit the event\n            if (this._state.initialized) {\n                this.emit('accountsChanged', _accounts);\n            }\n        }\n    }\n    /**\n     * Upon receipt of a new isUnlocked state, sets relevant public state.\n     * Calls the accounts changed handler with the received accounts, or an empty\n     * array.\n     *\n     * Does nothing if the received value is equal to the existing value.\n     * There are no lock/unlock events.\n     *\n     * @param opts - Options bag.\n     * @param opts.accounts - The exposed accounts, if any.\n     * @param opts.isUnlocked - The latest isUnlocked value.\n     */\n    _handleUnlockStateChanged({ accounts, isUnlocked, } = {}) {\n        if (typeof isUnlocked !== 'boolean') {\n            this._log.error('MetaMask: Received invalid isUnlocked parameter. Please report this bug.');\n            return;\n        }\n        if (isUnlocked !== this._state.isUnlocked) {\n            this._state.isUnlocked = isUnlocked;\n            this._handleAccountsChanged(accounts || []);\n        }\n    }\n}\nexports.default = BaseProvider;\nBaseProvider._defaultState = {\n    accounts: null,\n    isConnected: false,\n    isUnlocked: false,\n    initialized: false,\n    isPermanentlyDisconnected: false,\n};\n//# sourceMappingURL=BaseProvider.js.map"]},"metadata":{},"sourceType":"script"}