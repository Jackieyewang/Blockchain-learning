{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n\nconst siteMetadata_1 = __importDefault(require(\"./siteMetadata\"));\n\nconst messages_1 = __importDefault(require(\"./messages\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst BaseProvider_1 = __importDefault(require(\"./BaseProvider\"));\n\nclass MetaMaskInpageProvider extends BaseProvider_1.default {\n  /**\n   * @param connectionStream - A Node.js duplex stream\n   * @param options - An options bag\n   * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.\n   * Default: metamask-provider\n   * @param options.logger - The logging API to use. Default: console\n   * @param options.maxEventListeners - The maximum number of event\n   * listeners. Default: 100\n   * @param options.shouldSendMetadata - Whether the provider should\n   * send page metadata. Default: true\n   */\n  constructor(connectionStream, {\n    jsonRpcStreamName = 'metamask-provider',\n    logger = console,\n    maxEventListeners = 100,\n    shouldSendMetadata = true\n  } = {}) {\n    super(connectionStream, {\n      jsonRpcStreamName,\n      logger,\n      maxEventListeners\n    });\n    this._sentWarnings = {\n      // methods\n      enable: false,\n      experimentalMethods: false,\n      send: false,\n      // events\n      events: {\n        close: false,\n        data: false,\n        networkChanged: false,\n        notification: false\n      }\n    };\n    this.networkVersion = null;\n    this.isMetaMask = true;\n    this._sendSync = this._sendSync.bind(this);\n    this.enable = this.enable.bind(this);\n    this.send = this.send.bind(this);\n    this.sendAsync = this.sendAsync.bind(this);\n    this._warnOfDeprecation = this._warnOfDeprecation.bind(this);\n    this._metamask = this._getExperimentalApi(); // handle JSON-RPC notifications\n\n    this._jsonRpcConnection.events.on('notification', payload => {\n      const {\n        method\n      } = payload;\n\n      if (utils_1.EMITTED_NOTIFICATIONS.includes(method)) {\n        // deprecated\n        // emitted here because that was the original order\n        this.emit('data', payload); // deprecated\n\n        this.emit('notification', payload.params.result);\n      }\n    }); // send website metadata\n\n\n    if (shouldSendMetadata) {\n      if (document.readyState === 'complete') {\n        siteMetadata_1.default(this._rpcEngine, this._log);\n      } else {\n        const domContentLoadedHandler = () => {\n          siteMetadata_1.default(this._rpcEngine, this._log);\n          window.removeEventListener('DOMContentLoaded', domContentLoadedHandler);\n        };\n\n        window.addEventListener('DOMContentLoaded', domContentLoadedHandler);\n      }\n    }\n  } //====================\n  // Public Methods\n  //====================\n\n  /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   *\n   * @param payload - The RPC request object.\n   * @param cb - The callback function.\n   */\n\n\n  sendAsync(payload, callback) {\n    this._rpcRequest(payload, callback);\n  }\n  /**\n   * We override the following event methods so that we can warn consumers\n   * about deprecated events:\n   *   addListener, on, once, prependListener, prependOnceListener\n   */\n\n\n  addListener(eventName, listener) {\n    this._warnOfDeprecation(eventName);\n\n    return super.addListener(eventName, listener);\n  }\n\n  on(eventName, listener) {\n    this._warnOfDeprecation(eventName);\n\n    return super.on(eventName, listener);\n  }\n\n  once(eventName, listener) {\n    this._warnOfDeprecation(eventName);\n\n    return super.once(eventName, listener);\n  }\n\n  prependListener(eventName, listener) {\n    this._warnOfDeprecation(eventName);\n\n    return super.prependListener(eventName, listener);\n  }\n\n  prependOnceListener(eventName, listener) {\n    this._warnOfDeprecation(eventName);\n\n    return super.prependOnceListener(eventName, listener);\n  } //====================\n  // Private Methods\n  //====================\n\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * @emits MetaMaskInpageProvider#disconnect\n   */\n\n\n  _handleDisconnect(isRecoverable, errorMessage) {\n    super._handleDisconnect(isRecoverable, errorMessage);\n\n    if (this.networkVersion && !isRecoverable) {\n      this.networkVersion = null;\n    }\n  }\n  /**\n   * Warns of deprecation for the given event, if applicable.\n   */\n\n\n  _warnOfDeprecation(eventName) {\n    var _a;\n\n    if (((_a = this._sentWarnings) === null || _a === void 0 ? void 0 : _a.events[eventName]) === false) {\n      this._log.warn(messages_1.default.warnings.events[eventName]);\n\n      this._sentWarnings.events[eventName] = true;\n    }\n  } //====================\n  // Deprecated Methods\n  //====================\n\n  /**\n   * Equivalent to: ethereum.request('eth_requestAccounts')\n   *\n   * @deprecated Use request({ method: 'eth_requestAccounts' }) instead.\n   * @returns A promise that resolves to an array of addresses.\n   */\n\n\n  enable() {\n    if (!this._sentWarnings.enable) {\n      this._log.warn(messages_1.default.warnings.enableDeprecation);\n\n      this._sentWarnings.enable = true;\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        this._rpcRequest({\n          method: 'eth_requestAccounts',\n          params: []\n        }, utils_1.getRpcPromiseCallback(resolve, reject));\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  send(methodOrPayload, callbackOrArgs) {\n    if (!this._sentWarnings.send) {\n      this._log.warn(messages_1.default.warnings.sendDeprecation);\n\n      this._sentWarnings.send = true;\n    }\n\n    if (typeof methodOrPayload === 'string' && (!callbackOrArgs || Array.isArray(callbackOrArgs))) {\n      return new Promise((resolve, reject) => {\n        try {\n          this._rpcRequest({\n            method: methodOrPayload,\n            params: callbackOrArgs\n          }, utils_1.getRpcPromiseCallback(resolve, reject, false));\n        } catch (error) {\n          reject(error);\n        }\n      });\n    } else if (methodOrPayload && typeof methodOrPayload === 'object' && typeof callbackOrArgs === 'function') {\n      return this._rpcRequest(methodOrPayload, callbackOrArgs);\n    }\n\n    return this._sendSync(methodOrPayload);\n  }\n  /**\n   * Internal backwards compatibility method, used in send.\n   *\n   * @deprecated\n   */\n\n\n  _sendSync(payload) {\n    let result;\n\n    switch (payload.method) {\n      case 'eth_accounts':\n        result = this.selectedAddress ? [this.selectedAddress] : [];\n        break;\n\n      case 'eth_coinbase':\n        result = this.selectedAddress || null;\n        break;\n\n      case 'eth_uninstallFilter':\n        this._rpcRequest(payload, utils_1.NOOP);\n\n        result = true;\n        break;\n\n      case 'net_version':\n        result = this.networkVersion || null;\n        break;\n\n      default:\n        throw new Error(messages_1.default.errors.unsupportedSync(payload.method));\n    }\n\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result\n    };\n  }\n  /**\n   * Constructor helper.\n   * Gets experimental _metamask API as Proxy, so that we can warn consumers\n   * about its experiment nature.\n   */\n\n\n  _getExperimentalApi() {\n    return new Proxy({\n      /**\n       * Determines if MetaMask is unlocked by the user.\n       *\n       * @returns Promise resolving to true if MetaMask is currently unlocked\n       */\n      isUnlocked: async () => {\n        if (!this._state.initialized) {\n          await new Promise(resolve => {\n            this.on('_initialized', () => resolve());\n          });\n        }\n\n        return this._state.isUnlocked;\n      },\n\n      /**\n       * Make a batch RPC request.\n       */\n      requestBatch: async requests => {\n        if (!Array.isArray(requests)) {\n          throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n            message: 'Batch requests must be made with an array of request objects.',\n            data: requests\n          });\n        }\n\n        return new Promise((resolve, reject) => {\n          this._rpcRequest(requests, utils_1.getRpcPromiseCallback(resolve, reject));\n        });\n      }\n    }, {\n      get: (obj, prop, ...args) => {\n        if (!this._sentWarnings.experimentalMethods) {\n          this._log.warn(messages_1.default.warnings.experimentalMethods);\n\n          this._sentWarnings.experimentalMethods = true;\n        }\n\n        return Reflect.get(obj, prop, ...args);\n      }\n    });\n  }\n\n}\n\nexports.default = MetaMaskInpageProvider;","map":{"version":3,"sources":["../src/MetaMaskInpageProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\nconst siteMetadata_1 = __importDefault(require(\"./siteMetadata\"));\nconst messages_1 = __importDefault(require(\"./messages\"));\nconst utils_1 = require(\"./utils\");\nconst BaseProvider_1 = __importDefault(require(\"./BaseProvider\"));\nclass MetaMaskInpageProvider extends BaseProvider_1.default {\n    /**\n     * @param connectionStream - A Node.js duplex stream\n     * @param options - An options bag\n     * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.\n     * Default: metamask-provider\n     * @param options.logger - The logging API to use. Default: console\n     * @param options.maxEventListeners - The maximum number of event\n     * listeners. Default: 100\n     * @param options.shouldSendMetadata - Whether the provider should\n     * send page metadata. Default: true\n     */\n    constructor(connectionStream, { jsonRpcStreamName = 'metamask-provider', logger = console, maxEventListeners = 100, shouldSendMetadata = true, } = {}) {\n        super(connectionStream, { jsonRpcStreamName, logger, maxEventListeners });\n        this._sentWarnings = {\n            // methods\n            enable: false,\n            experimentalMethods: false,\n            send: false,\n            // events\n            events: {\n                close: false,\n                data: false,\n                networkChanged: false,\n                notification: false,\n            },\n        };\n        this.networkVersion = null;\n        this.isMetaMask = true;\n        this._sendSync = this._sendSync.bind(this);\n        this.enable = this.enable.bind(this);\n        this.send = this.send.bind(this);\n        this.sendAsync = this.sendAsync.bind(this);\n        this._warnOfDeprecation = this._warnOfDeprecation.bind(this);\n        this._metamask = this._getExperimentalApi();\n        // handle JSON-RPC notifications\n        this._jsonRpcConnection.events.on('notification', (payload) => {\n            const { method } = payload;\n            if (utils_1.EMITTED_NOTIFICATIONS.includes(method)) {\n                // deprecated\n                // emitted here because that was the original order\n                this.emit('data', payload);\n                // deprecated\n                this.emit('notification', payload.params.result);\n            }\n        });\n        // send website metadata\n        if (shouldSendMetadata) {\n            if (document.readyState === 'complete') {\n                siteMetadata_1.default(this._rpcEngine, this._log);\n            }\n            else {\n                const domContentLoadedHandler = () => {\n                    siteMetadata_1.default(this._rpcEngine, this._log);\n                    window.removeEventListener('DOMContentLoaded', domContentLoadedHandler);\n                };\n                window.addEventListener('DOMContentLoaded', domContentLoadedHandler);\n            }\n        }\n    }\n    //====================\n    // Public Methods\n    //====================\n    /**\n     * Submits an RPC request per the given JSON-RPC request object.\n     *\n     * @param payload - The RPC request object.\n     * @param cb - The callback function.\n     */\n    sendAsync(payload, callback) {\n        this._rpcRequest(payload, callback);\n    }\n    /**\n     * We override the following event methods so that we can warn consumers\n     * about deprecated events:\n     *   addListener, on, once, prependListener, prependOnceListener\n     */\n    addListener(eventName, listener) {\n        this._warnOfDeprecation(eventName);\n        return super.addListener(eventName, listener);\n    }\n    on(eventName, listener) {\n        this._warnOfDeprecation(eventName);\n        return super.on(eventName, listener);\n    }\n    once(eventName, listener) {\n        this._warnOfDeprecation(eventName);\n        return super.once(eventName, listener);\n    }\n    prependListener(eventName, listener) {\n        this._warnOfDeprecation(eventName);\n        return super.prependListener(eventName, listener);\n    }\n    prependOnceListener(eventName, listener) {\n        this._warnOfDeprecation(eventName);\n        return super.prependOnceListener(eventName, listener);\n    }\n    //====================\n    // Private Methods\n    //====================\n    /**\n     * When the provider becomes disconnected, updates internal state and emits\n     * required events. Idempotent with respect to the isRecoverable parameter.\n     *\n     * Error codes per the CloseEvent status codes as required by EIP-1193:\n     * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n     *\n     * @param isRecoverable - Whether the disconnection is recoverable.\n     * @param errorMessage - A custom error message.\n     * @emits MetaMaskInpageProvider#disconnect\n     */\n    _handleDisconnect(isRecoverable, errorMessage) {\n        super._handleDisconnect(isRecoverable, errorMessage);\n        if (this.networkVersion && !isRecoverable) {\n            this.networkVersion = null;\n        }\n    }\n    /**\n     * Warns of deprecation for the given event, if applicable.\n     */\n    _warnOfDeprecation(eventName) {\n        var _a;\n        if (((_a = this._sentWarnings) === null || _a === void 0 ? void 0 : _a.events[eventName]) === false) {\n            this._log.warn(messages_1.default.warnings.events[eventName]);\n            this._sentWarnings.events[eventName] = true;\n        }\n    }\n    //====================\n    // Deprecated Methods\n    //====================\n    /**\n     * Equivalent to: ethereum.request('eth_requestAccounts')\n     *\n     * @deprecated Use request({ method: 'eth_requestAccounts' }) instead.\n     * @returns A promise that resolves to an array of addresses.\n     */\n    enable() {\n        if (!this._sentWarnings.enable) {\n            this._log.warn(messages_1.default.warnings.enableDeprecation);\n            this._sentWarnings.enable = true;\n        }\n        return new Promise((resolve, reject) => {\n            try {\n                this._rpcRequest({ method: 'eth_requestAccounts', params: [] }, utils_1.getRpcPromiseCallback(resolve, reject));\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n    send(methodOrPayload, callbackOrArgs) {\n        if (!this._sentWarnings.send) {\n            this._log.warn(messages_1.default.warnings.sendDeprecation);\n            this._sentWarnings.send = true;\n        }\n        if (typeof methodOrPayload === 'string' &&\n            (!callbackOrArgs || Array.isArray(callbackOrArgs))) {\n            return new Promise((resolve, reject) => {\n                try {\n                    this._rpcRequest({ method: methodOrPayload, params: callbackOrArgs }, utils_1.getRpcPromiseCallback(resolve, reject, false));\n                }\n                catch (error) {\n                    reject(error);\n                }\n            });\n        }\n        else if (methodOrPayload &&\n            typeof methodOrPayload === 'object' &&\n            typeof callbackOrArgs === 'function') {\n            return this._rpcRequest(methodOrPayload, callbackOrArgs);\n        }\n        return this._sendSync(methodOrPayload);\n    }\n    /**\n     * Internal backwards compatibility method, used in send.\n     *\n     * @deprecated\n     */\n    _sendSync(payload) {\n        let result;\n        switch (payload.method) {\n            case 'eth_accounts':\n                result = this.selectedAddress ? [this.selectedAddress] : [];\n                break;\n            case 'eth_coinbase':\n                result = this.selectedAddress || null;\n                break;\n            case 'eth_uninstallFilter':\n                this._rpcRequest(payload, utils_1.NOOP);\n                result = true;\n                break;\n            case 'net_version':\n                result = this.networkVersion || null;\n                break;\n            default:\n                throw new Error(messages_1.default.errors.unsupportedSync(payload.method));\n        }\n        return {\n            id: payload.id,\n            jsonrpc: payload.jsonrpc,\n            result,\n        };\n    }\n    /**\n     * Constructor helper.\n     * Gets experimental _metamask API as Proxy, so that we can warn consumers\n     * about its experiment nature.\n     */\n    _getExperimentalApi() {\n        return new Proxy({\n            /**\n             * Determines if MetaMask is unlocked by the user.\n             *\n             * @returns Promise resolving to true if MetaMask is currently unlocked\n             */\n            isUnlocked: async () => {\n                if (!this._state.initialized) {\n                    await new Promise((resolve) => {\n                        this.on('_initialized', () => resolve());\n                    });\n                }\n                return this._state.isUnlocked;\n            },\n            /**\n             * Make a batch RPC request.\n             */\n            requestBatch: async (requests) => {\n                if (!Array.isArray(requests)) {\n                    throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n                        message: 'Batch requests must be made with an array of request objects.',\n                        data: requests,\n                    });\n                }\n                return new Promise((resolve, reject) => {\n                    this._rpcRequest(requests, utils_1.getRpcPromiseCallback(resolve, reject));\n                });\n            },\n        }, {\n            get: (obj, prop, ...args) => {\n                if (!this._sentWarnings.experimentalMethods) {\n                    this._log.warn(messages_1.default.warnings.experimentalMethods);\n                    this._sentWarnings.experimentalMethods = true;\n                }\n                return Reflect.get(obj, prop, ...args);\n            },\n        });\n    }\n}\nexports.default = MetaMaskInpageProvider;\n//# sourceMappingURL=MetaMaskInpageProvider.js.map"]},"metadata":{},"sourceType":"script"}