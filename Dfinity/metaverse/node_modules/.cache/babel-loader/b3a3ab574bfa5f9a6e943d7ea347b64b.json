{"ast":null,"code":"!function (g, c) {\n  typeof exports == \"object\" && typeof module != \"undefined\" ? c(exports) : typeof define == \"function\" && define.amd ? define([\"exports\"], c) : c((g = g || self).lru_map = g.lru_map || {});\n}(this, function (g) {\n  const c = Symbol(\"newer\"),\n        e = Symbol(\"older\");\n\n  class n {\n    constructor(a, b) {\n      typeof a !== \"number\" && (b = a, a = 0), this.size = 0, this.limit = a, this.oldest = this.newest = void 0, this._keymap = new Map(), b && (this.assign(b), a < 1 && (this.limit = this.size));\n    }\n\n    _markEntryAsUsed(a) {\n      if (a === this.newest) return;\n      a[c] && (a === this.oldest && (this.oldest = a[c]), a[c][e] = a[e]), a[e] && (a[e][c] = a[c]), a[c] = void 0, a[e] = this.newest, this.newest && (this.newest[c] = a), this.newest = a;\n    }\n\n    assign(a) {\n      let b,\n          d = this.limit || Number.MAX_VALUE;\n\n      this._keymap.clear();\n\n      let m = a[Symbol.iterator]();\n\n      for (let h = m.next(); !h.done; h = m.next()) {\n        let f = new l(h.value[0], h.value[1]);\n        this._keymap.set(f.key, f), b ? (b[c] = f, f[e] = b) : this.oldest = f, b = f;\n        if (d-- == 0) throw new Error(\"overflow\");\n      }\n\n      this.newest = b, this.size = this._keymap.size;\n    }\n\n    get(a) {\n      var b = this._keymap.get(a);\n\n      return b ? (this._markEntryAsUsed(b), b.value) : void 0;\n    }\n\n    set(a, b) {\n      var d = this._keymap.get(a);\n\n      return d ? (d.value = b, this._markEntryAsUsed(d), this) : (this._keymap.set(a, d = new l(a, b)), this.newest ? (this.newest[c] = d, d[e] = this.newest) : this.oldest = d, this.newest = d, ++this.size, this.size > this.limit && this.shift(), this);\n    }\n\n    shift() {\n      var a = this.oldest;\n      if (a) return this.oldest[c] ? (this.oldest = this.oldest[c], this.oldest[e] = void 0) : (this.oldest = void 0, this.newest = void 0), a[c] = a[e] = void 0, this._keymap.delete(a.key), --this.size, [a.key, a.value];\n    }\n\n    find(a) {\n      let b = this._keymap.get(a);\n\n      return b ? b.value : void 0;\n    }\n\n    has(a) {\n      return this._keymap.has(a);\n    }\n\n    delete(a) {\n      var b = this._keymap.get(a);\n\n      return b ? (this._keymap.delete(b.key), b[c] && b[e] ? (b[e][c] = b[c], b[c][e] = b[e]) : b[c] ? (b[c][e] = void 0, this.oldest = b[c]) : b[e] ? (b[e][c] = void 0, this.newest = b[e]) : this.oldest = this.newest = void 0, this.size--, b.value) : void 0;\n    }\n\n    clear() {\n      this.oldest = this.newest = void 0, this.size = 0, this._keymap.clear();\n    }\n\n    keys() {\n      return new j(this.oldest);\n    }\n\n    values() {\n      return new k(this.oldest);\n    }\n\n    entries() {\n      return this;\n    }\n\n    [Symbol.iterator]() {\n      return new i(this.oldest);\n    }\n\n    forEach(a, b) {\n      typeof b !== \"object\" && (b = this);\n      let d = this.oldest;\n\n      for (; d;) a.call(b, d.value, d.key, this), d = d[c];\n    }\n\n    toJSON() {\n      for (var a = new Array(this.size), b = 0, d = this.oldest; d;) a[b++] = {\n        key: d.key,\n        value: d.value\n      }, d = d[c];\n\n      return a;\n    }\n\n    toString() {\n      for (var a = \"\", b = this.oldest; b;) a += String(b.key) + \":\" + b.value, b = b[c], b && (a += \" < \");\n\n      return a;\n    }\n\n  }\n\n  g.LRUMap = n;\n\n  function l(a, b) {\n    this.key = a, this.value = b, this[c] = void 0, this[e] = void 0;\n  }\n\n  function i(a) {\n    this.entry = a;\n  }\n\n  i.prototype[Symbol.iterator] = function () {\n    return this;\n  }, i.prototype.next = function () {\n    let a = this.entry;\n    return a ? (this.entry = a[c], {\n      done: !1,\n      value: [a.key, a.value]\n    }) : {\n      done: !0,\n      value: void 0\n    };\n  };\n\n  function j(a) {\n    this.entry = a;\n  }\n\n  j.prototype[Symbol.iterator] = function () {\n    return this;\n  }, j.prototype.next = function () {\n    let a = this.entry;\n    return a ? (this.entry = a[c], {\n      done: !1,\n      value: a.key\n    }) : {\n      done: !0,\n      value: void 0\n    };\n  };\n\n  function k(a) {\n    this.entry = a;\n  }\n\n  k.prototype[Symbol.iterator] = function () {\n    return this;\n  }, k.prototype.next = function () {\n    let a = this.entry;\n    return a ? (this.entry = a[c], {\n      done: !1,\n      value: a.value\n    }) : {\n      done: !0,\n      value: void 0\n    };\n  };\n});","map":{"version":3,"sources":["lru.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n!function(g,f){\n  if (typeof exports == 'object' && typeof module != \"undefined\") {\n    f(exports)\n  } else if (typeof define == 'function' && define.amd) {\n    define([\"exports\"], f)\n  } else {\n    f((g = g || self)[\"lru_map\"] = (g[\"lru_map\"] || {}))\n  }\n}(this, function(exports) {\n\nconst NEWER = Symbol('newer');\nconst OLDER = Symbol('older');\n\nclass LRUMap {\n  constructor(limit, entries) {\n    if (typeof limit !== 'number') {\n      // called as (entries)\n      entries = limit;\n      limit = 0;\n    }\n\n    this.size = 0;\n    this.limit = limit;\n    this.oldest = this.newest = undefined;\n    this._keymap = new Map();\n\n    if (entries) {\n      this.assign(entries);\n      if (limit < 1) {\n        this.limit = this.size;\n      }\n    }\n  }\n\n  _markEntryAsUsed(entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER];\n      }\n      entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n    }\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n    }\n    entry[NEWER] = undefined; // D --x\n    entry[OLDER] = this.newest; // D. --> E\n    if (this.newest) {\n      this.newest[NEWER] = entry; // E. <-- D\n    }\n    this.newest = entry;\n  }\n\n  assign(entries) {\n    let entry, limit = this.limit || Number.MAX_VALUE;\n    this._keymap.clear();\n    let it = entries[Symbol.iterator]();\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = new Entry(itv.value[0], itv.value[1]);\n      this._keymap.set(e.key, e);\n      if (!entry) {\n        this.oldest = e;\n      } else {\n        entry[NEWER] = e;\n        e[OLDER] = entry;\n      }\n      entry = e;\n      if (limit-- == 0) {\n        throw new Error('overflow');\n      }\n    }\n    this.newest = entry;\n    this.size = this._keymap.size;\n  }\n\n  get(key) {\n    // First, find our cache entry\n    var entry = this._keymap.get(key);\n    if (!entry) return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    this._markEntryAsUsed(entry);\n    return entry.value;\n  }\n\n  set(key, value) {\n    var entry = this._keymap.get(key);\n\n    if (entry) {\n      // update existing\n      entry.value = value;\n      this._markEntryAsUsed(entry);\n      return this;\n    }\n\n    // new entry\n    this._keymap.set(key, (entry = new Entry(key, value)));\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry;\n      entry[OLDER] = this.newest;\n    } else {\n      // we're first in -- yay\n      this.oldest = entry;\n    }\n\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.newest = entry;\n    ++this.size;\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift();\n    }\n\n    return this;\n  }\n\n  shift() {\n    // todo: handle special case when limit == 1\n    var entry = this.oldest;\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER];\n        this.oldest[OLDER] = undefined;\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined;\n        this.newest = undefined;\n      }\n      // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n      entry[NEWER] = entry[OLDER] = undefined;\n      this._keymap.delete(entry.key);\n      --this.size;\n      return [entry.key, entry.value];\n    }\n  }\n\n  // -------------------------------------------------------------------------------------\n  // Following code (until end of class definition) is optional and can be removed without\n  // breaking the core functionality.\n\n  find(key) {\n    let e = this._keymap.get(key);\n    return e ? e.value : undefined;\n  }\n\n  has(key) {\n    return this._keymap.has(key);\n  }\n\n  delete(key) {\n    var entry = this._keymap.get(key);\n    if (!entry) return;\n    this._keymap.delete(entry.key);\n    if (entry[NEWER] && entry[OLDER]) {\n      // relink the older entry with the newer entry\n      entry[OLDER][NEWER] = entry[NEWER];\n      entry[NEWER][OLDER] = entry[OLDER];\n    } else if (entry[NEWER]) {\n      // remove the link to us\n      entry[NEWER][OLDER] = undefined;\n      // link the newer entry to head\n      this.oldest = entry[NEWER];\n    } else if (entry[OLDER]) {\n      // remove the link to us\n      entry[OLDER][NEWER] = undefined;\n      // link the newer entry to head\n      this.newest = entry[OLDER];\n    } else {// if(entry[OLDER] === undefined && entry.newer === undefined) {\n      this.oldest = this.newest = undefined;\n    }\n\n    this.size--;\n    return entry.value;\n  }\n\n  clear() {\n    // Not clearing links should be safe, as we don't expose live links to user\n    this.oldest = this.newest = undefined;\n    this.size = 0;\n    this._keymap.clear();\n  }\n\n  keys() {\n    return new KeyIterator(this.oldest);\n  }\n\n  values() {\n    return new ValueIterator(this.oldest);\n  }\n\n  entries() {\n    return this;\n  }\n\n  [Symbol.iterator]() {\n    return new EntryIterator(this.oldest);\n  }\n\n  forEach(fun, thisObj) {\n    if (typeof thisObj !== 'object') {\n      thisObj = this;\n    }\n    let entry = this.oldest;\n    while (entry) {\n      fun.call(thisObj, entry.value, entry.key, this);\n      entry = entry[NEWER];\n    }\n  }\n\n  /** Returns a JSON (array) representation */\n  toJSON() {\n    var s = new Array(this.size), i = 0, entry = this.oldest;\n    while (entry) {\n      s[i++] = { key: entry.key, value: entry.value };\n      entry = entry[NEWER];\n    }\n    return s;\n  }\n\n  /** Returns a String representation */\n  toString() {\n    var s = '', entry = this.oldest;\n    while (entry) {\n      s += String(entry.key)+':'+entry.value;\n      entry = entry[NEWER];\n      if (entry) {\n        s += ' < ';\n      }\n    }\n    return s;\n  }\n}\n\nexports.LRUMap = LRUMap\n\nfunction Entry(key, value) {\n  this.key = key;\n  this.value = value;\n  this[NEWER] = undefined;\n  this[OLDER] = undefined;\n}\n\n\nfunction EntryIterator(oldestEntry) { this.entry = oldestEntry; }\nEntryIterator.prototype[Symbol.iterator] = function() { return this; }\nEntryIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: [ent.key, ent.value] };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nfunction KeyIterator(oldestEntry) { this.entry = oldestEntry; }\nKeyIterator.prototype[Symbol.iterator] = function() { return this; }\nKeyIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.key };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\nfunction ValueIterator(oldestEntry) { this.entry = oldestEntry; }\nValueIterator.prototype[Symbol.iterator] = function() { return this; }\nValueIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.value };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n});\n"]},"metadata":{},"sourceType":"script"}