{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toStableObject = exports.decodeBase64 = exports.encodeBase64 = exports.u8aToHex = exports.hexToU8A = exports.parseJWEKids = exports.decodeKey = exports.encodeKey = void 0;\n\nconst fast_json_stable_stringify_1 = __importDefault(require(\"fast-json-stable-stringify\"));\n\nconst u8a = __importStar(require(\"uint8arrays\"));\n\nconst B16 = 'base16';\nconst B64 = 'base64pad';\nconst multicodecPubkeyTable = {\n  secp256k1: 0xe7,\n  x25519: 0xec,\n  ed25519: 0xed\n};\n\nfunction encodeKey(key, keyType) {\n  const bytes = new Uint8Array(key.length + 2);\n\n  if (!multicodecPubkeyTable[keyType]) {\n    throw new Error(`Key type \"${keyType}\" not supported.`);\n  }\n\n  bytes[0] = multicodecPubkeyTable[keyType];\n  bytes[1] = 0x01;\n  bytes.set(key, 2);\n  return `z${u8a.toString(bytes, 'base58btc')}`;\n}\n\nexports.encodeKey = encodeKey;\n\nfunction decodeKey(key) {\n  const bytes = u8a.fromString(key.slice(1), 'base58btc');\n  const supportedKey = bytes[1] === 0x01 && (multicodecPubkeyTable['secp256k1'] === bytes[0] || multicodecPubkeyTable['x25519'] === bytes[0] || multicodecPubkeyTable['ed25519'] === bytes[0]);\n  if (!supportedKey) throw new Error(`Key type ${bytes[0]} not supported`);\n  return bytes.slice(2);\n}\n\nexports.decodeKey = decodeKey;\n\nfunction parseJWEKids(jwe) {\n  var _a;\n\n  return ((_a = jwe.recipients) === null || _a === void 0 ? void 0 : _a.reduce((kids, recipient) => {\n    var _a;\n\n    if ((_a = recipient.header) === null || _a === void 0 ? void 0 : _a.kid) kids.push(recipient.header.kid.split('#')[1]);\n    return kids;\n  }, [])) || [];\n}\n\nexports.parseJWEKids = parseJWEKids;\n\nfunction hexToU8A(s) {\n  return u8a.fromString(s, B16);\n}\n\nexports.hexToU8A = hexToU8A;\n\nfunction u8aToHex(b) {\n  return u8a.toString(b, B16);\n}\n\nexports.u8aToHex = u8aToHex;\n\nfunction encodeBase64(b) {\n  return u8a.toString(b, B64);\n}\n\nexports.encodeBase64 = encodeBase64;\n\nfunction decodeBase64(s) {\n  return u8a.fromString(s, B64);\n}\n\nexports.decodeBase64 = decodeBase64;\n\nfunction toStableObject(obj) {\n  return JSON.parse(fast_json_stable_stringify_1.default(obj));\n}\n\nexports.toStableObject = toStableObject;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toStableObject = exports.decodeBase64 = exports.encodeBase64 = exports.u8aToHex = exports.hexToU8A = exports.parseJWEKids = exports.decodeKey = exports.encodeKey = void 0;\nconst fast_json_stable_stringify_1 = __importDefault(require(\"fast-json-stable-stringify\"));\nconst u8a = __importStar(require(\"uint8arrays\"));\nconst B16 = 'base16';\nconst B64 = 'base64pad';\nconst multicodecPubkeyTable = {\n    secp256k1: 0xe7,\n    x25519: 0xec,\n    ed25519: 0xed,\n};\nfunction encodeKey(key, keyType) {\n    const bytes = new Uint8Array(key.length + 2);\n    if (!multicodecPubkeyTable[keyType]) {\n        throw new Error(`Key type \"${keyType}\" not supported.`);\n    }\n    bytes[0] = multicodecPubkeyTable[keyType];\n    bytes[1] = 0x01;\n    bytes.set(key, 2);\n    return `z${u8a.toString(bytes, 'base58btc')}`;\n}\nexports.encodeKey = encodeKey;\nfunction decodeKey(key) {\n    const bytes = u8a.fromString(key.slice(1), 'base58btc');\n    const supportedKey = bytes[1] === 0x01 &&\n        (multicodecPubkeyTable['secp256k1'] === bytes[0] ||\n            multicodecPubkeyTable['x25519'] === bytes[0] ||\n            multicodecPubkeyTable['ed25519'] === bytes[0]);\n    if (!supportedKey)\n        throw new Error(`Key type ${bytes[0]} not supported`);\n    return bytes.slice(2);\n}\nexports.decodeKey = decodeKey;\nfunction parseJWEKids(jwe) {\n    var _a;\n    return (((_a = jwe.recipients) === null || _a === void 0 ? void 0 : _a.reduce((kids, recipient) => {\n        var _a;\n        if ((_a = recipient.header) === null || _a === void 0 ? void 0 : _a.kid)\n            kids.push(recipient.header.kid.split('#')[1]);\n        return kids;\n    }, [])) || []);\n}\nexports.parseJWEKids = parseJWEKids;\nfunction hexToU8A(s) {\n    return u8a.fromString(s, B16);\n}\nexports.hexToU8A = hexToU8A;\nfunction u8aToHex(b) {\n    return u8a.toString(b, B16);\n}\nexports.u8aToHex = u8aToHex;\nfunction encodeBase64(b) {\n    return u8a.toString(b, B64);\n}\nexports.encodeBase64 = encodeBase64;\nfunction decodeBase64(s) {\n    return u8a.fromString(s, B64);\n}\nexports.decodeBase64 = decodeBase64;\nfunction toStableObject(obj) {\n    return JSON.parse(fast_json_stable_stringify_1.default(obj));\n}\nexports.toStableObject = toStableObject;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}