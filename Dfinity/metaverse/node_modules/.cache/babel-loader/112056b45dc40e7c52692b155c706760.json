{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\n\nconst u8a = __importStar(require(\"uint8arrays\"));\n\nconst lru_map_1 = require(\"lru_map\");\n\nconst THREEBOX_API_URL = 'https://ipfs.3box.io';\nconst LIMIT = 100;\nconst fetchCache = new lru_map_1.LRUMap(LIMIT);\n\nconst fetchJson = async url => {\n  const cached = fetchCache.get(url);\n  if (cached) return cached;\n  const r = await cross_fetch_1.default(url);\n\n  if (r.ok) {\n    const json = await r.json();\n    fetchCache.set(url, json);\n    return json;\n  } else {\n    throw new Error('Not a valid 3ID');\n  }\n};\n\nconst didDocReq = cid => `${THREEBOX_API_URL}/did-doc?cid=${encodeURIComponent(cid)}`;\n\nconst ipfsMock = {\n  dag: {\n    get: async cid => fetchJson(didDocReq(cid))\n  }\n};\n\nconst encodeKey = (key, encryption) => {\n  const bytes = new Uint8Array(key.length + 2);\n\n  if (encryption) {\n    bytes[0] = 0xec;\n  } else {\n    bytes[0] = 0xe7;\n  }\n\n  bytes[1] = 0x01;\n  bytes.set(key, 2);\n  return `z${u8a.toString(bytes, 'base58btc')}`;\n};\n\nconst compressKey = key => {\n  const xpoint = key.slice(2, 66);\n  const ypoint = key.slice(66, 130);\n  const prefix = (ypoint & 1) === 0 ? '02' : '03';\n  return `${prefix}${xpoint}`;\n};\n\nconst LegacyResolver = async (didId, ipfs = ipfsMock) => {\n  const doc = (await ipfs.dag.get(didId)).value;\n  let signingKey, encryptionKey;\n\n  try {\n    const keyEntrySigning = doc.publicKey.findIndex(e => e.id.endsWith('signingKey'));\n    const keyEntryEncryption = doc.publicKey.findIndex(e => e.id.endsWith('encryptionKey'));\n    signingKey = doc.publicKey[keyEntrySigning].publicKeyHex;\n    encryptionKey = doc.publicKey[keyEntryEncryption].publicKeyBase64;\n  } catch (e) {\n    throw new Error('Not a valid 3ID');\n  }\n\n  const signingKeyCompressed = compressKey(signingKey);\n  const signing = encodeKey(u8a.fromString(signingKeyCompressed, 'base16'));\n  const encryption = encodeKey(u8a.fromString(encryptionKey, 'base64pad'), true);\n  return {\n    keyDid: `did:key:${signing}`,\n    publicKeys: {\n      [signing.slice(-15)]: signing,\n      [encryption.slice(-15)]: encryption\n    }\n  };\n};\n\nexports.default = LegacyResolver;","map":{"version":3,"sources":["../src/legacyResolver.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nconst u8a = __importStar(require(\"uint8arrays\"));\nconst lru_map_1 = require(\"lru_map\");\nconst THREEBOX_API_URL = 'https://ipfs.3box.io';\nconst LIMIT = 100;\nconst fetchCache = new lru_map_1.LRUMap(LIMIT);\nconst fetchJson = async (url) => {\n    const cached = fetchCache.get(url);\n    if (cached)\n        return cached;\n    const r = await cross_fetch_1.default(url);\n    if (r.ok) {\n        const json = await r.json();\n        fetchCache.set(url, json);\n        return json;\n    }\n    else {\n        throw new Error('Not a valid 3ID');\n    }\n};\nconst didDocReq = (cid) => `${THREEBOX_API_URL}/did-doc?cid=${encodeURIComponent(cid)}`;\nconst ipfsMock = {\n    dag: {\n        get: async (cid) => fetchJson(didDocReq(cid))\n    }\n};\nconst encodeKey = (key, encryption) => {\n    const bytes = new Uint8Array(key.length + 2);\n    if (encryption) {\n        bytes[0] = 0xec;\n    }\n    else {\n        bytes[0] = 0xe7;\n    }\n    bytes[1] = 0x01;\n    bytes.set(key, 2);\n    return `z${u8a.toString(bytes, 'base58btc')}`;\n};\nconst compressKey = (key) => {\n    const xpoint = key.slice(2, 66);\n    const ypoint = key.slice(66, 130);\n    const prefix = (ypoint & 1) === 0 ? '02' : '03';\n    return `${prefix}${xpoint}`;\n};\nconst LegacyResolver = async (didId, ipfs = ipfsMock) => {\n    const doc = (await ipfs.dag.get(didId)).value;\n    let signingKey, encryptionKey;\n    try {\n        const keyEntrySigning = doc.publicKey.findIndex(e => e.id.endsWith('signingKey'));\n        const keyEntryEncryption = doc.publicKey.findIndex(e => e.id.endsWith('encryptionKey'));\n        signingKey = doc.publicKey[keyEntrySigning].publicKeyHex;\n        encryptionKey = doc.publicKey[keyEntryEncryption].publicKeyBase64;\n    }\n    catch (e) {\n        throw new Error('Not a valid 3ID');\n    }\n    const signingKeyCompressed = compressKey(signingKey);\n    const signing = encodeKey(u8a.fromString(signingKeyCompressed, 'base16'));\n    const encryption = encodeKey(u8a.fromString(encryptionKey, 'base64pad'), true);\n    return {\n        keyDid: `did:key:${signing}`,\n        publicKeys: {\n            [signing.slice(-15)]: signing,\n            [encryption.slice(-15)]: encryption,\n        }\n    };\n};\nexports.default = LegacyResolver;\n//# sourceMappingURL=legacyResolver.js.map"]},"metadata":{},"sourceType":"script"}