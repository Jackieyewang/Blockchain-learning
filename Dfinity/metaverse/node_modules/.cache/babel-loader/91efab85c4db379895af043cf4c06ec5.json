{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EMITTED_NOTIFICATIONS = exports.NOOP = exports.logStreamDisconnectWarning = exports.getRpcPromiseCallback = exports.createErrorMiddleware = void 0;\n\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\"); // utility functions\n\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */\n\n\nfunction createErrorMiddleware(log) {\n  return (req, res, next) => {\n    // json-rpc-engine will terminate the request when it notices this error\n    if (typeof req.method !== 'string' || !req.method) {\n      res.error = eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n        message: `The request 'method' must be a non-empty string.`,\n        data: req\n      });\n    }\n\n    next(done => {\n      const {\n        error\n      } = res;\n\n      if (!error) {\n        return done();\n      }\n\n      log.error(`MetaMask - RPC Error: ${error.message}`, error);\n      return done();\n    });\n  };\n}\n\nexports.createErrorMiddleware = createErrorMiddleware; // resolve response.result or response, reject errors\n\nconst getRpcPromiseCallback = (resolve, reject, unwrapResult = true) => (error, response) => {\n  if (error || response.error) {\n    reject(error || response.error);\n  } else {\n    !unwrapResult || Array.isArray(response) ? resolve(response) : resolve(response.result);\n  }\n};\n\nexports.getRpcPromiseCallback = getRpcPromiseCallback;\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */\n\nfunction logStreamDisconnectWarning(log, remoteLabel, error, emitter) {\n  let warningMsg = `MetaMask: Lost connection to \"${remoteLabel}\".`;\n\n  if (error === null || error === void 0 ? void 0 : error.stack) {\n    warningMsg += `\\n${error.stack}`;\n  }\n\n  log.warn(warningMsg);\n\n  if (emitter && emitter.listenerCount('error') > 0) {\n    emitter.emit('error', warningMsg);\n  }\n}\n\nexports.logStreamDisconnectWarning = logStreamDisconnectWarning;\n\nconst NOOP = () => undefined;\n\nexports.NOOP = NOOP; // constants\n\nexports.EMITTED_NOTIFICATIONS = ['eth_subscription'];","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";;;;;;;AAEA,MAAA,gBAAA,GAAA,OAAA,CAAA,gBAAA,CAAA,C,CASA;;AAEA;;;;;AAKG;;;AACH,SAAgB,qBAAhB,CACE,GADF,EACkB;AAEhB,SAAO,CAAC,GAAD,EAAM,GAAN,EAAW,IAAX,KAAmB;AACxB;AACA,QAAI,OAAO,GAAG,CAAC,MAAX,KAAsB,QAAtB,IAAkC,CAAC,GAAG,CAAC,MAA3C,EAAmD;AACjD,MAAA,GAAG,CAAC,KAAJ,GAAY,gBAAA,CAAA,SAAA,CAAU,GAAV,CAAc,cAAd,CAA6B;AACvC,QAAA,OAAO,EAAE,kDAD8B;AAEvC,QAAA,IAAI,EAAE;AAFiC,OAA7B,CAAZ;AAID;;AAED,IAAA,IAAI,CAAE,IAAD,IAAS;AACZ,YAAM;AAAE,QAAA;AAAF,UAAY,GAAlB;;AACA,UAAI,CAAC,KAAL,EAAY;AACV,eAAO,IAAI,EAAX;AACD;;AACD,MAAA,GAAG,CAAC,KAAJ,CAAU,yBAAyB,KAAK,CAAC,OAAO,EAAhD,EAAoD,KAApD;AACA,aAAO,IAAI,EAAX;AACD,KAPG,CAAJ;AAQD,GAjBD;AAkBD;;AArBD,OAAA,CAAA,qBAAA,GAAA,qBAAA,C,CAuBA;;AACO,MAAM,qBAAqB,GAAG,CACnC,OADmC,EAEnC,MAFmC,EAGnC,YAAY,GAAG,IAHoB,KAIhC,CAAC,KAAD,EAAe,QAAf,KAAkE;AACrE,MAAI,KAAK,IAAI,QAAQ,CAAC,KAAtB,EAA6B;AAC3B,IAAA,MAAM,CAAC,KAAK,IAAI,QAAQ,CAAC,KAAnB,CAAN;AACD,GAFD,MAEO;AACL,KAAC,YAAD,IAAiB,KAAK,CAAC,OAAN,CAAc,QAAd,CAAjB,GACI,OAAO,CAAC,QAAD,CADX,GAEI,OAAO,CAAC,QAAQ,CAAC,MAAV,CAFX;AAGD;AACF,CAZM;;AAAM,OAAA,CAAA,qBAAA,GAAqB,qBAArB;AAcb;;;;;;;;AAQG;;AACH,SAAgB,0BAAhB,CACE,GADF,EAEE,WAFF,EAGE,KAHF,EAIE,OAJF,EAIuB;AAErB,MAAI,UAAU,GAAG,iCAAiC,WAAW,IAA7D;;AACA,MAAI,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,KAAX,EAAkB;AAChB,IAAA,UAAU,IAAI,KAAK,KAAK,CAAC,KAAK,EAA9B;AACD;;AACD,EAAA,GAAG,CAAC,IAAJ,CAAS,UAAT;;AACA,MAAI,OAAO,IAAI,OAAO,CAAC,aAAR,CAAsB,OAAtB,IAAiC,CAAhD,EAAmD;AACjD,IAAA,OAAO,CAAC,IAAR,CAAa,OAAb,EAAsB,UAAtB;AACD;AACF;;AAdD,OAAA,CAAA,0BAAA,GAAA,0BAAA;;AAgBO,MAAM,IAAI,GAAG,MAAM,SAAnB;;AAAM,OAAA,CAAA,IAAA,GAAI,IAAJ,C,CAEb;;AAEa,OAAA,CAAA,qBAAA,GAAwB,CACnC,kBADmC,CAAxB","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EMITTED_NOTIFICATIONS = exports.NOOP = exports.logStreamDisconnectWarning = exports.getRpcPromiseCallback = exports.createErrorMiddleware = void 0;\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n// utility functions\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */\nfunction createErrorMiddleware(log) {\n    return (req, res, next) => {\n        // json-rpc-engine will terminate the request when it notices this error\n        if (typeof req.method !== 'string' || !req.method) {\n            res.error = eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n                message: `The request 'method' must be a non-empty string.`,\n                data: req,\n            });\n        }\n        next((done) => {\n            const { error } = res;\n            if (!error) {\n                return done();\n            }\n            log.error(`MetaMask - RPC Error: ${error.message}`, error);\n            return done();\n        });\n    };\n}\nexports.createErrorMiddleware = createErrorMiddleware;\n// resolve response.result or response, reject errors\nconst getRpcPromiseCallback = (resolve, reject, unwrapResult = true) => (error, response) => {\n    if (error || response.error) {\n        reject(error || response.error);\n    }\n    else {\n        !unwrapResult || Array.isArray(response)\n            ? resolve(response)\n            : resolve(response.result);\n    }\n};\nexports.getRpcPromiseCallback = getRpcPromiseCallback;\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */\nfunction logStreamDisconnectWarning(log, remoteLabel, error, emitter) {\n    let warningMsg = `MetaMask: Lost connection to \"${remoteLabel}\".`;\n    if (error === null || error === void 0 ? void 0 : error.stack) {\n        warningMsg += `\\n${error.stack}`;\n    }\n    log.warn(warningMsg);\n    if (emitter && emitter.listenerCount('error') > 0) {\n        emitter.emit('error', warningMsg);\n    }\n}\nexports.logStreamDisconnectWarning = logStreamDisconnectWarning;\nconst NOOP = () => undefined;\nexports.NOOP = NOOP;\n// constants\nexports.EMITTED_NOTIFICATIONS = [\n    'eth_subscription',\n];\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}