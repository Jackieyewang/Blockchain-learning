{"ast":null,"code":"function t() {\n  return (t = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var r = arguments[e];\n\n      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nfunction e() {\n  const t = new Map();\n  return async (e, r) => {\n    var n;\n    if (e.params && \"true\" === e.params[\"no-cache\"]) return await r();\n    const a = t.get(e.didUrl);\n    if (void 0 !== a) return a;\n    const i = await r();\n    return \"notFound\" !== (null == (n = i.didResolutionMetadata) ? void 0 : n.error) && t.set(e.didUrl, i), i;\n  };\n}\n\nfunction r(t, e) {\n  return e();\n}\n\nconst n = new RegExp(\"^did:([a-zA-Z0-9_]+):([a-zA-Z0-9_.%-]+(:[a-zA-Z0-9_.%-]+)*)((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$\");\n\nfunction a(t) {\n  if (\"\" === t || !t) return null;\n  const e = t.match(n);\n\n  if (e) {\n    const r = {\n      did: `did:${e[1]}:${e[2]}`,\n      method: e[1],\n      id: e[2],\n      didUrl: t\n    };\n\n    if (e[4]) {\n      const t = e[4].slice(1).split(\";\");\n      r.params = {};\n\n      for (const e of t) {\n        const t = e.split(\"=\");\n        r.params[t[0]] = t[1];\n      }\n    }\n\n    return e[6] && (r.path = e[6]), e[7] && (r.query = e[7].slice(1)), e[8] && (r.fragment = e[8].slice(1)), r;\n  }\n\n  return null;\n}\n\nconst i = {\n  didResolutionMetadata: {},\n  didDocument: null,\n  didDocumentMetadata: {}\n};\n\nfunction o(e) {\n  return async (r, n, a) => {\n    try {\n      const o = await e(r, n, a);\n      return t({}, i, {\n        didResolutionMetadata: {\n          contentType: \"application/did+ld+json\"\n        },\n        didDocument: o\n      });\n    } catch (e) {\n      return t({}, i, {\n        didResolutionMetadata: {\n          error: \"notFound\",\n          message: e.toString()\n        }\n      });\n    }\n  };\n}\n\nclass s {\n  constructor(t = {}, n = {}) {\n    this.registry = t, this.cache = !0 === n.cache ? e() : n.cache || r, n.legacyResolvers && Object.keys(n.legacyResolvers).map(t => {\n      this.registry[t] || (this.registry[t] = o(n.legacyResolvers[t]));\n    });\n  }\n\n  async resolve(e, r = {}) {\n    const n = a(e);\n    if (null === n) return t({}, i, {\n      didResolutionMetadata: {\n        error: \"invalidDid\"\n      }\n    });\n    const o = this.registry[n.method];\n    return o ? this.cache(n, () => o(n.did, n, this, r)) : t({}, i, {\n      didResolutionMetadata: {\n        error: \"unsupportedDidMethod\"\n      }\n    });\n  }\n\n}\n\nexport { s as Resolver, e as inMemoryCache, r as noCache, a as parse, o as wrapLegacyResolver };","map":{"version":3,"sources":["../src/resolver.ts"],"names":["inMemoryCache","cache","Map","parsed","resolve","params","cached","get","didUrl","undefined","result","didResolutionMetadata","error","set","noCache","DID_MATCHER","RegExp","parse","sections","match","parts","did","method","id","slice","split","p","kv","path","query","fragment","EMPTY_RESULT","didDocument","didDocumentMetadata","wrapLegacyResolver","resolver","doc","contentType","e","message","toString","Resolver","constructor","registry","options","this","legacyResolvers","Object","keys","map","methodName","[object Object]"],"mappings":"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","sourcesContent":["// Copyright 2018 Consensys AG\n\n// Licensed under the Apache License, Version 2.0(the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n// http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Extensible = Record<string, any>\n\nexport interface DIDResolutionResult {\n  didResolutionMetadata: DIDResolutionMetadata\n  didDocument: DIDDocument | null\n  didDocumentMetadata: DIDDocumentMetadata\n}\n\nexport interface DIDResolutionOptions extends Extensible {\n  accept?: string\n}\n\nexport interface DIDResolutionMetadata extends Extensible {\n  contentType?: string\n  error?:\n    | 'invalidDid'\n    | 'notFound'\n    | 'representationNotSupported'\n    | 'unsupportedDidMethod'\n    | string\n}\n\nexport interface DIDDocumentMetadata extends Extensible {\n  created?: string\n  updated?: string\n  deactivated?: boolean\n  versionId?: string\n  nextUpdate?: string\n  nextVersionId?: string\n  equivalentId?: string\n  canonicalId?: string\n}\n\nexport interface DIDDocument {\n  '@context'?: 'https://www.w3.org/ns/did/v1' | string | string[]\n  id: string\n  alsoKnownAs?: string[]\n  controller?: string | string[]\n  verificationMethod?: VerificationMethod[]\n  authentication?: (string | VerificationMethod)[]\n  assertionMethod?: (string | VerificationMethod)[]\n  keyAgreement?: (string | VerificationMethod)[]\n  capabilityInvocation?: (string | VerificationMethod)[]\n  capabilityDelegation?: (string | VerificationMethod)[]\n  service?: ServiceEndpoint[]\n  /**\n   * @deprecated\n   */\n  publicKey?: VerificationMethod[]\n}\n\nexport interface ServiceEndpoint {\n  id: string\n  type: string\n  serviceEndpoint: string\n  description?: string\n}\n\ninterface JsonWebKey extends Extensible {\n  alg?: string\n  crv?: string\n  e?: string\n  ext?: boolean\n  key_ops?: string[]\n  kid?: string\n  kty: string\n  n?: string\n  use?: string\n  x?: string\n  y?: string\n}\n\nexport interface VerificationMethod {\n  id: string\n  type: string\n  controller: string\n  publicKeyBase58?: string\n  publicKeyJwk?: JsonWebKey\n  publicKeyHex?: string\n  blockchainAccountId?: string\n  ethereumAddress?: string\n}\n\nexport interface Params {\n  [index: string]: string\n}\n\nexport interface ParsedDID {\n  did: string\n  didUrl: string\n  method: string\n  id: string\n  path?: string\n  fragment?: string\n  query?: string\n  params?: Params\n}\n\nexport type DIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolver,\n  options: DIDResolutionOptions\n) => Promise<DIDResolutionResult>\nexport type WrappedResolver = () => Promise<DIDResolutionResult>\nexport type DIDCache = (\n  parsed: ParsedDID,\n  resolve: WrappedResolver\n) => Promise<DIDResolutionResult>\nexport type LegacyDIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolver\n) => Promise<DIDDocument>\n\nexport interface ResolverRegistry {\n  [index: string]: DIDResolver\n}\n\nexport interface LegacyResolverRegistry {\n  [index: string]: LegacyDIDResolver\n}\n\nexport interface ResolverOptions {\n  cache?: DIDCache | boolean | undefined\n  legacyResolvers?: LegacyResolverRegistry\n}\n\nexport function inMemoryCache(): DIDCache {\n  const cache: Map<string, DIDResolutionResult> = new Map()\n  return async (parsed: ParsedDID, resolve) => {\n    if (parsed.params && parsed.params['no-cache'] === 'true')\n      return await resolve()\n\n    const cached = cache.get(parsed.didUrl)\n    if (cached !== undefined) return cached\n    const result = await resolve()\n    if (result.didResolutionMetadata?.error !== 'notFound') {\n      cache.set(parsed.didUrl, result)\n    }\n    return result\n  }\n}\n\nexport function noCache(\n  parsed: ParsedDID,\n  resolve: WrappedResolver\n): Promise<DIDResolutionResult> {\n  return resolve()\n}\n\nconst ID_CHAR = '[a-zA-Z0-9_.%-]'\nconst METHOD = '([a-zA-Z0-9_]+)'\nconst METHOD_ID = `(${ID_CHAR}+(:${ID_CHAR}+)*)`\nconst PARAM_CHAR = '[a-zA-Z0-9_.:%-]'\nconst PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`\nconst PARAMS = `((${PARAM})*)`\nconst PATH = `(\\/[^#?]*)?`\nconst QUERY = `([?][^#]*)?`\nconst FRAGMENT = `(\\#.*)?`\nconst DID_MATCHER = new RegExp(\n  `^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`\n)\nexport function parse(didUrl: string): ParsedDID | null {\n  if (didUrl === '' || !didUrl) return null\n  const sections = didUrl.match(DID_MATCHER)\n  if (sections) {\n    const parts: ParsedDID = {\n      did: `did:${sections[1]}:${sections[2]}`,\n      method: sections[1],\n      id: sections[2],\n      didUrl\n    }\n    if (sections[4]) {\n      const params = sections[4].slice(1).split(';')\n      parts.params = {}\n      for (const p of params) {\n        const kv = p.split('=')\n        parts.params[kv[0]] = kv[1]\n      }\n    }\n    if (sections[6]) parts.path = sections[6]\n    if (sections[7]) parts.query = sections[7].slice(1)\n    if (sections[8]) parts.fragment = sections[8].slice(1)\n    return parts\n  }\n  return null\n}\n\nconst EMPTY_RESULT: DIDResolutionResult = {\n  didResolutionMetadata: {},\n  didDocument: null,\n  didDocumentMetadata: {}\n}\n\nexport function wrapLegacyResolver(resolve: LegacyDIDResolver): DIDResolver {\n  return async (did, parsed, resolver) => {\n    try {\n      const doc = await resolve(did, parsed, resolver)\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { contentType: 'application/did+ld+json' },\n        didDocument: doc\n      }\n    } catch (e) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: {\n          error: 'notFound',\n          message: e.toString() // This is not in spec, nut may be helpful\n        }\n      }\n    }\n  }\n}\n\nexport type Resolvable = {\n  resolve: (\n    didUrl: string,\n    options?: DIDResolutionOptions\n  ) => Promise<DIDResolutionResult>\n}\n\nexport class Resolver implements Resolvable {\n  private registry: ResolverRegistry\n  private cache: DIDCache\n\n  constructor(registry: ResolverRegistry = {}, options: ResolverOptions = {}) {\n    this.registry = registry\n    this.cache =\n      options.cache === true ? inMemoryCache() : options.cache || noCache\n    if (options.legacyResolvers) {\n      Object.keys(options.legacyResolvers).map((methodName) => {\n        if (!this.registry[methodName]) {\n          this.registry[methodName] = wrapLegacyResolver(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            options.legacyResolvers![methodName]\n          )\n        }\n      })\n    }\n  }\n\n  async resolve(\n    didUrl: string,\n    options: DIDResolutionOptions = {}\n  ): Promise<DIDResolutionResult> {\n    const parsed = parse(didUrl)\n    if (parsed === null) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'invalidDid' }\n      }\n    }\n    const resolver = this.registry[parsed.method]\n    if (!resolver) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'unsupportedDidMethod' }\n      }\n    }\n    return this.cache(parsed, () => resolver(parsed.did, parsed, this, options))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}