{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapDocument = void 0;\n\nconst stream_tile_1 = require(\"@ceramicnetwork/stream-tile\");\n\nconst legacyResolver_1 = __importDefault(require(\"./legacyResolver\"));\n\nconst u8a = __importStar(require(\"uint8arrays\"));\n\nconst streamid_1 = require(\"@ceramicnetwork/streamid\");\n\nconst cids_1 = __importDefault(require(\"cids\"));\n\nconst DID_LD_JSON = 'application/did+ld+json';\nconst DID_JSON = 'application/did+json';\n\nconst isLegacyDid = didId => {\n  try {\n    new cids_1.default(didId);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nconst formatTime = timestamp => {\n  return new Date(timestamp * 1000).toISOString().split('.')[0] + 'Z';\n};\n\nfunction wrapDocument(content, did) {\n  if (!(content && content.publicKeys)) return null;\n  const startDoc = {\n    id: did,\n    verificationMethod: [],\n    authentication: [],\n    keyAgreement: []\n  };\n  return Object.entries(content.publicKeys).reduce((diddoc, [keyName, keyValue]) => {\n    const keyBuf = u8a.fromString(keyValue.slice(1), 'base58btc');\n    const entry = {\n      id: `${did}#${keyName}`,\n      type: '',\n      controller: did,\n      publicKeyBase58: u8a.toString(keyBuf.slice(2), 'base58btc')\n    };\n\n    if (keyBuf[0] === 0xe7) {\n      entry.type = 'EcdsaSecp256k1Signature2019';\n      diddoc.verificationMethod.push(entry);\n      diddoc.authentication.push(entry);\n    } else if (keyBuf[0] === 0xec) {\n      entry.type = 'X25519KeyAgreementKey2019';\n      diddoc.verificationMethod.push(entry);\n      diddoc.keyAgreement.push(entry);\n    }\n\n    return diddoc;\n  }, startDoc);\n}\n\nexports.wrapDocument = wrapDocument;\n\nfunction extractMetadata(requestedVersionState, latestVersionState) {\n  var _a;\n\n  const metadata = {};\n  const {\n    timestamp: updated,\n    cid: versionId\n  } = requestedVersionState.log.pop() || {};\n  const {\n    timestamp: nextUpdate,\n    cid: nextVersionId\n  } = latestVersionState.log.find(({\n    timestamp\n  }) => timestamp > updated || !updated && timestamp) || {};\n  const created = (_a = latestVersionState.log.find(({\n    timestamp\n  }) => Boolean(timestamp))) === null || _a === void 0 ? void 0 : _a.timestamp;\n\n  if (created) {\n    metadata.created = formatTime(created);\n  }\n\n  if (updated) {\n    metadata.updated = formatTime(updated);\n  }\n\n  if (nextUpdate) {\n    metadata.nextUpdate = formatTime(nextUpdate);\n  }\n\n  if (versionId) {\n    metadata.versionId = requestedVersionState.log.length === 0 ? '0' : versionId === null || versionId === void 0 ? void 0 : versionId.toString();\n  }\n\n  if (nextVersionId) {\n    metadata.nextVersionId = nextVersionId.toString();\n  }\n\n  return metadata;\n}\n\nfunction getVersionInfo(query = '') {\n  const versionId = query.split('&').find(e => e.includes('versionId') || e.includes('version-id'));\n  const versionTime = query.split('&').find(e => e.includes('versionTime'));\n  return {\n    commit: versionId ? versionId.split('=')[1] : undefined,\n    timestamp: versionTime ? Math.floor(new Date(versionTime.split('=')[1]).getTime() / 1000) : undefined\n  };\n}\n\nconst legacyResolve = async (ceramic, didId, verNfo) => {\n  const legacyPublicKeys = await legacyResolver_1.default(didId);\n  const metadata = {\n    controllers: [legacyPublicKeys.keyDid],\n    family: '3id',\n    deterministic: true\n  };\n  const streamid = (await stream_tile_1.TileDocument.create(ceramic, null, metadata, {\n    anchor: false,\n    publish: false\n  })).id;\n  const didResult = await resolve(ceramic, streamid.toString(), verNfo, didId);\n\n  if (didResult.didDocument === null) {\n    didResult.didDocument = wrapDocument(legacyPublicKeys, `did:3:${didId}`);\n  }\n\n  return didResult;\n};\n\nconst resolve = async (ceramic, didId, verNfo, v03ID) => {\n  var _a;\n\n  const streamId = streamid_1.StreamID.fromString(didId);\n  let commitId;\n  const query = [{\n    streamId\n  }];\n\n  if (verNfo.commit) {\n    commitId = streamId.atCommit(verNfo.commit);\n    query.push({\n      streamId: commitId\n    });\n  } else if (verNfo.timestamp) {\n    query.push({\n      streamId,\n      atTime: verNfo.timestamp\n    });\n  }\n\n  const resp = await ceramic.multiQuery(query);\n  const latestVersionState = resp[didId].state;\n  const commitIdStr = (commitId === null || commitId === void 0 ? void 0 : commitId.toString()) || Object.keys(resp).find(k => k !== didId);\n  const requestedVersionState = ((_a = resp[commitIdStr]) === null || _a === void 0 ? void 0 : _a.state) || latestVersionState;\n  const metadata = extractMetadata(requestedVersionState, latestVersionState);\n  const tile = resp[commitIdStr || didId];\n\n  if (commitIdStr && !tile) {\n    throw new Error(`No resolution for commit ${commitIdStr}`);\n  }\n\n  const content = tile.content;\n  const document = wrapDocument(content, `did:3:${v03ID || didId}`);\n  return {\n    didResolutionMetadata: {\n      contentType: DID_JSON\n    },\n    didDocument: document,\n    didDocumentMetadata: metadata\n  };\n};\n\nexports.default = {\n  getResolver: ceramic => ({\n    '3': async (did, parsed, resolver, options) => {\n      const contentType = options.accept || DID_JSON;\n\n      try {\n        const verNfo = getVersionInfo(parsed.query);\n        const didResult = await (isLegacyDid(parsed.id) ? legacyResolve(ceramic, parsed.id, verNfo) : resolve(ceramic, parsed.id, verNfo));\n\n        if (contentType === DID_LD_JSON) {\n          didResult.didDocument['@context'] = 'https://www.w3.org/ns/did/v1';\n          didResult.didResolutionMetadata.contentType = DID_LD_JSON;\n        } else if (contentType !== DID_JSON) {\n          didResult.didDocument = null;\n          didResult.didDocumentMetadata = {};\n          delete didResult.didResolutionMetadata.contentType;\n          didResult.didResolutionMetadata.error = 'representationNotSupported';\n        }\n\n        return didResult;\n      } catch (e) {\n        return {\n          didResolutionMetadata: {\n            error: 'invalidDid',\n            message: e.toString()\n          },\n          didDocument: null,\n          didDocumentMetadata: {}\n        };\n      }\n    }\n  })\n};","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wrapDocument = void 0;\nconst stream_tile_1 = require(\"@ceramicnetwork/stream-tile\");\nconst legacyResolver_1 = __importDefault(require(\"./legacyResolver\"));\nconst u8a = __importStar(require(\"uint8arrays\"));\nconst streamid_1 = require(\"@ceramicnetwork/streamid\");\nconst cids_1 = __importDefault(require(\"cids\"));\nconst DID_LD_JSON = 'application/did+ld+json';\nconst DID_JSON = 'application/did+json';\nconst isLegacyDid = (didId) => {\n    try {\n        new cids_1.default(didId);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nconst formatTime = (timestamp) => {\n    return (new Date(timestamp * 1000)).toISOString().split('.')[0] + 'Z';\n};\nfunction wrapDocument(content, did) {\n    if (!(content && content.publicKeys))\n        return null;\n    const startDoc = {\n        id: did,\n        verificationMethod: [],\n        authentication: [],\n        keyAgreement: [],\n    };\n    return Object.entries(content.publicKeys).reduce((diddoc, [keyName, keyValue]) => {\n        const keyBuf = u8a.fromString(keyValue.slice(1), 'base58btc');\n        const entry = {\n            id: `${did}#${keyName}`,\n            type: '',\n            controller: did,\n            publicKeyBase58: u8a.toString(keyBuf.slice(2), 'base58btc')\n        };\n        if (keyBuf[0] === 0xe7) {\n            entry.type = 'EcdsaSecp256k1Signature2019';\n            diddoc.verificationMethod.push(entry);\n            diddoc.authentication.push(entry);\n        }\n        else if (keyBuf[0] === 0xec) {\n            entry.type = 'X25519KeyAgreementKey2019';\n            diddoc.verificationMethod.push(entry);\n            diddoc.keyAgreement.push(entry);\n        }\n        return diddoc;\n    }, startDoc);\n}\nexports.wrapDocument = wrapDocument;\nfunction extractMetadata(requestedVersionState, latestVersionState) {\n    var _a;\n    const metadata = {};\n    const { timestamp: updated, cid: versionId } = requestedVersionState.log.pop() || {};\n    const { timestamp: nextUpdate, cid: nextVersionId } = latestVersionState.log.find(({ timestamp }) => timestamp > updated || (!updated && timestamp)) || {};\n    const created = (_a = latestVersionState.log.find(({ timestamp }) => Boolean(timestamp))) === null || _a === void 0 ? void 0 : _a.timestamp;\n    if (created) {\n        metadata.created = formatTime(created);\n    }\n    if (updated) {\n        metadata.updated = formatTime(updated);\n    }\n    if (nextUpdate) {\n        metadata.nextUpdate = formatTime(nextUpdate);\n    }\n    if (versionId) {\n        metadata.versionId = requestedVersionState.log.length === 0 ? '0' : versionId === null || versionId === void 0 ? void 0 : versionId.toString();\n    }\n    if (nextVersionId) {\n        metadata.nextVersionId = nextVersionId.toString();\n    }\n    return metadata;\n}\nfunction getVersionInfo(query = '') {\n    const versionId = query.split('&').find(e => e.includes('versionId') || e.includes('version-id'));\n    const versionTime = query.split('&').find(e => e.includes('versionTime'));\n    return {\n        commit: versionId ? versionId.split('=')[1] : undefined,\n        timestamp: versionTime ? Math.floor((new Date(versionTime.split('=')[1])).getTime() / 1000) : undefined\n    };\n}\nconst legacyResolve = async (ceramic, didId, verNfo) => {\n    const legacyPublicKeys = await legacyResolver_1.default(didId);\n    const metadata = { controllers: [legacyPublicKeys.keyDid], family: '3id', deterministic: true };\n    const streamid = (await stream_tile_1.TileDocument.create(ceramic, null, metadata, { anchor: false, publish: false })).id;\n    const didResult = await resolve(ceramic, streamid.toString(), verNfo, didId);\n    if (didResult.didDocument === null) {\n        didResult.didDocument = wrapDocument(legacyPublicKeys, `did:3:${didId}`);\n    }\n    return didResult;\n};\nconst resolve = async (ceramic, didId, verNfo, v03ID) => {\n    var _a;\n    const streamId = streamid_1.StreamID.fromString(didId);\n    let commitId;\n    const query = [{ streamId }];\n    if (verNfo.commit) {\n        commitId = streamId.atCommit(verNfo.commit);\n        query.push({ streamId: commitId });\n    }\n    else if (verNfo.timestamp) {\n        query.push({\n            streamId,\n            atTime: verNfo.timestamp\n        });\n    }\n    const resp = await ceramic.multiQuery(query);\n    const latestVersionState = resp[didId].state;\n    const commitIdStr = (commitId === null || commitId === void 0 ? void 0 : commitId.toString()) || Object.keys(resp).find(k => k !== didId);\n    const requestedVersionState = ((_a = resp[commitIdStr]) === null || _a === void 0 ? void 0 : _a.state) || latestVersionState;\n    const metadata = extractMetadata(requestedVersionState, latestVersionState);\n    const tile = resp[commitIdStr || didId];\n    if (commitIdStr && !tile) {\n        throw new Error(`No resolution for commit ${commitIdStr}`);\n    }\n    const content = tile.content;\n    const document = wrapDocument(content, `did:3:${v03ID || didId}`);\n    return {\n        didResolutionMetadata: { contentType: DID_JSON },\n        didDocument: document,\n        didDocumentMetadata: metadata\n    };\n};\nexports.default = {\n    getResolver: (ceramic) => ({\n        '3': async (did, parsed, resolver, options) => {\n            const contentType = options.accept || DID_JSON;\n            try {\n                const verNfo = getVersionInfo(parsed.query);\n                const didResult = await (isLegacyDid(parsed.id) ? legacyResolve(ceramic, parsed.id, verNfo) : resolve(ceramic, parsed.id, verNfo));\n                if (contentType === DID_LD_JSON) {\n                    didResult.didDocument['@context'] = 'https://www.w3.org/ns/did/v1';\n                    didResult.didResolutionMetadata.contentType = DID_LD_JSON;\n                }\n                else if (contentType !== DID_JSON) {\n                    didResult.didDocument = null;\n                    didResult.didDocumentMetadata = {};\n                    delete didResult.didResolutionMetadata.contentType;\n                    didResult.didResolutionMetadata.error = 'representationNotSupported';\n                }\n                return didResult;\n            }\n            catch (e) {\n                return {\n                    didResolutionMetadata: {\n                        error: 'invalidDid',\n                        message: e.toString()\n                    },\n                    didDocument: null,\n                    didDocumentMetadata: {}\n                };\n            }\n        }\n    })\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}