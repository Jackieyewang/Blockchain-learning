{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LATEST = void 0;\n\nconst x25519_1 = require(\"@stablelib/x25519\");\n\nconst hdnode_1 = require(\"@ethersproject/hdnode\");\n\nconst did_jwt_1 = require(\"did-jwt\");\n\nconst random_1 = require(\"@stablelib/random\");\n\nconst dag_jose_utils_1 = require(\"dag-jose-utils\");\n\nconst utils_1 = require(\"./utils\");\n\nexports.LATEST = 'latest';\nconst GENESIS = 'genesis';\nconst BASE_PATH = \"m/51073068'\";\nconst LEGACY_BASE_PATH = \"m/7696500'/0'/0'\";\n\nfunction deriveKeySet(seed, v03ID) {\n  const seedNode = hdnode_1.HDNode.fromSeed(seed);\n  let hdNode;\n\n  if (v03ID) {\n    hdNode = seedNode.derivePath(LEGACY_BASE_PATH);\n  } else {\n    hdNode = seedNode.derivePath(BASE_PATH);\n  }\n\n  const signing = hdNode.derivePath('0');\n  const management = v03ID ? signing : hdNode.derivePath('1');\n  const encryption = x25519_1.generateKeyPairFromSeed(utils_1.hexToU8A(hdNode.derivePath('2').privateKey.slice(2)));\n  return {\n    seed,\n    publicKeys: {\n      signing: utils_1.hexToU8A(signing.publicKey.slice(2)),\n      management: utils_1.hexToU8A(management.publicKey.slice(2)),\n      encryption: encryption.publicKey\n    },\n    secretKeys: {\n      signing: utils_1.hexToU8A(signing.privateKey.slice(2)),\n      management: utils_1.hexToU8A(management.privateKey.slice(2)),\n      encryption: encryption.secretKey\n    },\n    v03ID\n  };\n}\n\nclass Keyring {\n  constructor(seed, v03ID) {\n    this._keySets = {};\n    this._versionMap = {};\n    this._pastSeeds = [];\n\n    if (!seed) {\n      seed = random_1.randomBytes(32);\n    }\n\n    if (v03ID) this._v03ID = v03ID;\n    this._versionMap[GENESIS] = exports.LATEST;\n    this._keySets[exports.LATEST] = deriveKeySet(seed, v03ID);\n    let encKid = utils_1.encodeKey(this._keySets[exports.LATEST].publicKeys.encryption, 'x25519').slice(-15);\n    this._versionMap[encKid] = exports.LATEST;\n    encKid = utils_1.encodeKey(this._keySets[exports.LATEST].publicKeys.management, 'secp256k1');\n    this._versionMap[encKid] = exports.LATEST;\n  }\n\n  get v03ID() {\n    return this._v03ID;\n  }\n\n  get seed() {\n    return this._keySets[exports.LATEST].seed;\n  }\n\n  get pastSeeds() {\n    return this._pastSeeds;\n  }\n\n  loadPastSeeds(pastSeeds) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._pastSeeds = [...pastSeeds];\n      let version = exports.LATEST;\n      let jwe = pastSeeds.pop();\n\n      while (jwe) {\n        const decrypted = yield this.asymDecryptJWE(jwe, [], version);\n        version = Object.keys(decrypted).find(k => k !== 'v03ID');\n\n        if (decrypted.v03ID) {\n          this._v03ID = decrypted.v03ID;\n          delete decrypted.v03ID;\n          this._versionMap[GENESIS] = version;\n        }\n\n        this._keySets[version] = deriveKeySet(new Uint8Array(decrypted[version]), this._v03ID);\n\n        this._updateVersionMap(version, this._keySets[version]);\n\n        jwe = pastSeeds.pop();\n      }\n    });\n  }\n\n  _updateVersionMap(version, keySet) {\n    let encKid = utils_1.encodeKey(keySet.publicKeys.encryption, 'x25519').slice(-15);\n    this._versionMap[encKid] = version;\n    encKid = utils_1.encodeKey(keySet.publicKeys.management, 'secp256k1');\n    this._versionMap[encKid] = version;\n  }\n\n  generateNewKeys(prevVersion) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._keySets[prevVersion]) throw new Error('Key set version already exist');\n\n      this._updateVersionMap(prevVersion, this._keySets[exports.LATEST]);\n\n      this._keySets[prevVersion] = this._keySets[exports.LATEST];\n      this._keySets[exports.LATEST] = deriveKeySet(random_1.randomBytes(32));\n\n      this._updateVersionMap(exports.LATEST, this._keySets[exports.LATEST]);\n\n      const cleartext = {\n        [prevVersion]: this._keySets[prevVersion].seed\n      };\n      if (this._keySets[prevVersion].v03ID) cleartext.v03ID = this._keySets[prevVersion].v03ID;\n\n      this._pastSeeds.push(yield this.asymEncryptJWE(cleartext));\n    });\n  }\n\n  getAsymDecrypter(fragments = [], version) {\n    if (!version) {\n      const fragmentWithKey = fragments.find(fragment => this._versionMap[fragment]);\n      version = fragmentWithKey ? this._versionMap[fragmentWithKey] : exports.LATEST;\n    }\n\n    const key = this._keySets[version].secretKeys.encryption;\n    return did_jwt_1.x25519Decrypter(key);\n  }\n\n  asymDecryptJWE(jwe, kids, version) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return dag_jose_utils_1.decodeCleartext(yield did_jwt_1.decryptJWE(jwe, this.getAsymDecrypter(kids, version)));\n    });\n  }\n\n  asymEncryptJWE(cleartext, kid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const encrypter = did_jwt_1.x25519Encrypter(this.getEncryptionPublicKey(), kid);\n      return did_jwt_1.createJWE(dag_jose_utils_1.prepareCleartext(cleartext), [encrypter]);\n    });\n  }\n\n  getSigner(version = exports.LATEST) {\n    const keyset = this._keySets[version] || this._keySets[exports.LATEST];\n    return did_jwt_1.EllipticSigner(utils_1.u8aToHex(keyset.secretKeys.signing));\n  }\n\n  getKeyFragment(version = exports.LATEST, encKey = false) {\n    const keyset = this._keySets[version] || this._keySets[exports.LATEST];\n\n    if (encKey) {\n      return utils_1.encodeKey(keyset.publicKeys.encryption, 'x25519').slice(-15);\n    }\n\n    return utils_1.encodeKey(keyset.publicKeys.signing, 'secp256k1').slice(-15);\n  }\n\n  getMgmtSigner(pubKey) {\n    const keyset = this._keySets[this._versionMap[pubKey]].secretKeys;\n    if (!keyset) throw new Error(`Key not found: ${pubKey}`);\n    return did_jwt_1.EllipticSigner(utils_1.u8aToHex(keyset.management));\n  }\n\n  getEncryptionPublicKey() {\n    return this._keySets[exports.LATEST].publicKeys.encryption;\n  }\n\n  get3idState(genesis) {\n    const keyVer = genesis ? this._versionMap[GENESIS] : exports.LATEST;\n    const keys = this._keySets[keyVer].publicKeys;\n    const signing = utils_1.encodeKey(keys.signing, 'secp256k1');\n    const encryption = utils_1.encodeKey(keys.encryption, 'x25519');\n    const state = {\n      metadata: {\n        controllers: [`did:key:${utils_1.encodeKey(keys.management, 'secp256k1')}`]\n      },\n      content: {\n        publicKeys: {\n          [signing.slice(-15)]: signing,\n          [encryption.slice(-15)]: encryption\n        }\n      }\n    };\n\n    if (genesis) {\n      state.metadata.family = '3id';\n    }\n\n    if (this._keySets[keyVer].v03ID) {\n      state.metadata.deterministic = true;\n      delete state.content;\n    }\n\n    return state;\n  }\n\n}\n\nexports.default = Keyring;","map":{"version":3,"sources":["../src/keyring.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LATEST = void 0;\nconst x25519_1 = require(\"@stablelib/x25519\");\nconst hdnode_1 = require(\"@ethersproject/hdnode\");\nconst did_jwt_1 = require(\"did-jwt\");\nconst random_1 = require(\"@stablelib/random\");\nconst dag_jose_utils_1 = require(\"dag-jose-utils\");\nconst utils_1 = require(\"./utils\");\nexports.LATEST = 'latest';\nconst GENESIS = 'genesis';\nconst BASE_PATH = \"m/51073068'\";\nconst LEGACY_BASE_PATH = \"m/7696500'/0'/0'\";\nfunction deriveKeySet(seed, v03ID) {\n    const seedNode = hdnode_1.HDNode.fromSeed(seed);\n    let hdNode;\n    if (v03ID) {\n        hdNode = seedNode.derivePath(LEGACY_BASE_PATH);\n    }\n    else {\n        hdNode = seedNode.derivePath(BASE_PATH);\n    }\n    const signing = hdNode.derivePath('0');\n    const management = v03ID ? signing : hdNode.derivePath('1');\n    const encryption = x25519_1.generateKeyPairFromSeed(utils_1.hexToU8A(hdNode.derivePath('2').privateKey.slice(2)));\n    return {\n        seed,\n        publicKeys: {\n            signing: utils_1.hexToU8A(signing.publicKey.slice(2)),\n            management: utils_1.hexToU8A(management.publicKey.slice(2)),\n            encryption: encryption.publicKey,\n        },\n        secretKeys: {\n            signing: utils_1.hexToU8A(signing.privateKey.slice(2)),\n            management: utils_1.hexToU8A(management.privateKey.slice(2)),\n            encryption: encryption.secretKey,\n        },\n        v03ID,\n    };\n}\nclass Keyring {\n    constructor(seed, v03ID) {\n        this._keySets = {};\n        this._versionMap = {};\n        this._pastSeeds = [];\n        if (!seed) {\n            seed = random_1.randomBytes(32);\n        }\n        if (v03ID)\n            this._v03ID = v03ID;\n        this._versionMap[GENESIS] = exports.LATEST;\n        this._keySets[exports.LATEST] = deriveKeySet(seed, v03ID);\n        let encKid = utils_1.encodeKey(this._keySets[exports.LATEST].publicKeys.encryption, 'x25519').slice(-15);\n        this._versionMap[encKid] = exports.LATEST;\n        encKid = utils_1.encodeKey(this._keySets[exports.LATEST].publicKeys.management, 'secp256k1');\n        this._versionMap[encKid] = exports.LATEST;\n    }\n    get v03ID() {\n        return this._v03ID;\n    }\n    get seed() {\n        return this._keySets[exports.LATEST].seed;\n    }\n    get pastSeeds() {\n        return this._pastSeeds;\n    }\n    loadPastSeeds(pastSeeds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._pastSeeds = [...pastSeeds];\n            let version = exports.LATEST;\n            let jwe = pastSeeds.pop();\n            while (jwe) {\n                const decrypted = yield this.asymDecryptJWE(jwe, [], version);\n                version = Object.keys(decrypted).find((k) => k !== 'v03ID');\n                if (decrypted.v03ID) {\n                    this._v03ID = decrypted.v03ID;\n                    delete decrypted.v03ID;\n                    this._versionMap[GENESIS] = version;\n                }\n                this._keySets[version] = deriveKeySet(new Uint8Array(decrypted[version]), this._v03ID);\n                this._updateVersionMap(version, this._keySets[version]);\n                jwe = pastSeeds.pop();\n            }\n        });\n    }\n    _updateVersionMap(version, keySet) {\n        let encKid = utils_1.encodeKey(keySet.publicKeys.encryption, 'x25519').slice(-15);\n        this._versionMap[encKid] = version;\n        encKid = utils_1.encodeKey(keySet.publicKeys.management, 'secp256k1');\n        this._versionMap[encKid] = version;\n    }\n    generateNewKeys(prevVersion) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._keySets[prevVersion])\n                throw new Error('Key set version already exist');\n            this._updateVersionMap(prevVersion, this._keySets[exports.LATEST]);\n            this._keySets[prevVersion] = this._keySets[exports.LATEST];\n            this._keySets[exports.LATEST] = deriveKeySet(random_1.randomBytes(32));\n            this._updateVersionMap(exports.LATEST, this._keySets[exports.LATEST]);\n            const cleartext = { [prevVersion]: this._keySets[prevVersion].seed };\n            if (this._keySets[prevVersion].v03ID)\n                cleartext.v03ID = this._keySets[prevVersion].v03ID;\n            this._pastSeeds.push(yield this.asymEncryptJWE(cleartext));\n        });\n    }\n    getAsymDecrypter(fragments = [], version) {\n        if (!version) {\n            const fragmentWithKey = fragments.find((fragment) => this._versionMap[fragment]);\n            version = fragmentWithKey ? this._versionMap[fragmentWithKey] : exports.LATEST;\n        }\n        const key = this._keySets[version].secretKeys.encryption;\n        return did_jwt_1.x25519Decrypter(key);\n    }\n    asymDecryptJWE(jwe, kids, version) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return dag_jose_utils_1.decodeCleartext(yield did_jwt_1.decryptJWE(jwe, this.getAsymDecrypter(kids, version)));\n        });\n    }\n    asymEncryptJWE(cleartext, kid) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const encrypter = did_jwt_1.x25519Encrypter(this.getEncryptionPublicKey(), kid);\n            return did_jwt_1.createJWE(dag_jose_utils_1.prepareCleartext(cleartext), [encrypter]);\n        });\n    }\n    getSigner(version = exports.LATEST) {\n        const keyset = this._keySets[version] || this._keySets[exports.LATEST];\n        return did_jwt_1.EllipticSigner(utils_1.u8aToHex(keyset.secretKeys.signing));\n    }\n    getKeyFragment(version = exports.LATEST, encKey = false) {\n        const keyset = this._keySets[version] || this._keySets[exports.LATEST];\n        if (encKey) {\n            return utils_1.encodeKey(keyset.publicKeys.encryption, 'x25519').slice(-15);\n        }\n        return utils_1.encodeKey(keyset.publicKeys.signing, 'secp256k1').slice(-15);\n    }\n    getMgmtSigner(pubKey) {\n        const keyset = this._keySets[this._versionMap[pubKey]].secretKeys;\n        if (!keyset)\n            throw new Error(`Key not found: ${pubKey}`);\n        return did_jwt_1.EllipticSigner(utils_1.u8aToHex(keyset.management));\n    }\n    getEncryptionPublicKey() {\n        return this._keySets[exports.LATEST].publicKeys.encryption;\n    }\n    get3idState(genesis) {\n        const keyVer = genesis ? this._versionMap[GENESIS] : exports.LATEST;\n        const keys = this._keySets[keyVer].publicKeys;\n        const signing = utils_1.encodeKey(keys.signing, 'secp256k1');\n        const encryption = utils_1.encodeKey(keys.encryption, 'x25519');\n        const state = {\n            metadata: { controllers: [`did:key:${utils_1.encodeKey(keys.management, 'secp256k1')}`] },\n            content: {\n                publicKeys: {\n                    [signing.slice(-15)]: signing,\n                    [encryption.slice(-15)]: encryption,\n                },\n            },\n        };\n        if (genesis) {\n            state.metadata.family = '3id';\n        }\n        if (this._keySets[keyVer].v03ID) {\n            state.metadata.deterministic = true;\n            delete state.content;\n        }\n        return state;\n    }\n}\nexports.default = Keyring;\n//# sourceMappingURL=keyring.js.map"]},"metadata":{},"sourceType":"script"}