{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toSignedPayload = exports.toPayload = exports.EosioAuthProvider = void 0;\n\nconst caip_1 = require(\"caip\");\n\nconst util_1 = require(\"./util\");\n\nconst ethereum_1 = require(\"./ethereum\");\n\nconst sha256Stable = __importStar(require(\"@stablelib/sha256\"));\n\nconst uint8arrays = __importStar(require(\"uint8arrays\"));\n\nconst maxWordLength = 12;\n\nclass EosioAuthProvider {\n  constructor(provider, address) {\n    this.provider = provider;\n    this.address = address;\n    this.isAuthProvider = true;\n  }\n\n  async accountId() {\n    const chainId = toCAIPChainId(await this.provider.getChainId());\n    return new caip_1.AccountID({\n      address: this.address,\n      chainId: `eosio:${chainId}`\n    });\n  }\n\n  async authenticate(message) {\n    const accountID = await this.accountId();\n    const signedPayload = await toSignedPayload(message, accountID, this.provider);\n    const signatureBytes = uint8arrays.fromString(signedPayload);\n    const digest = sha256Stable.hash(signatureBytes);\n    return `0x${uint8arrays.toString(digest, 'base16')}`;\n  }\n\n  async createLink(did) {\n    const consentMessage = util_1.getConsentMessage(did);\n    const accountID = await this.accountId();\n    const signedPayload = await toSignedPayload(consentMessage.message, accountID, this.provider);\n    return {\n      version: 1,\n      type: \"eosio\",\n      message: consentMessage.message,\n      signature: signedPayload,\n      account: accountID.toString(),\n      timestamp: consentMessage.timestamp\n    };\n  }\n\n  withAddress(address) {\n    return new EosioAuthProvider(this.provider, address);\n  }\n\n}\n\nexports.EosioAuthProvider = EosioAuthProvider;\n\nfunction toCAIPChainId(chainId) {\n  return chainId.substr(0, 32);\n}\n\nfunction sanitize(str, size) {\n  return str.replace(/\\s/g, \" \").replace(new RegExp(`(\\\\S{${size}})`, \"g\"), \"$1 \");\n}\n\nfunction toPayload(message, accountID) {\n  const {\n    address,\n    chainId\n  } = accountID;\n  const payload = `${message} [For: ${address} on chain: ${chainId}]`;\n  return sanitize(payload, maxWordLength);\n}\n\nexports.toPayload = toPayload;\n\nasync function toSignedPayload(message, accountID, provider) {\n  accountID = ethereum_1.normalizeAccountId(accountID);\n  const {\n    chainId: {\n      reference: requestedChainId\n    },\n    address\n  } = accountID;\n  const accountName = await provider.getAccountName();\n  const chainId = toCAIPChainId(await provider.getChainId());\n\n  if (chainId !== requestedChainId) {\n    throw new Error(`Provider returned a different chainId than requested [returned: ${chainId}, requested: ${requestedChainId}]`);\n  }\n\n  if (accountName !== address) {\n    throw new Error(`Provider returned a different account than requested [returned: ${accountName}, requested: ${address}]`);\n  }\n\n  const payload = toPayload(message, accountID);\n  const [key] = await provider.getKeys();\n  return provider.signArbitrary(key, payload);\n}\n\nexports.toSignedPayload = toSignedPayload;","map":{"version":3,"sources":["../src/eosio.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toSignedPayload = exports.toPayload = exports.EosioAuthProvider = void 0;\nconst caip_1 = require(\"caip\");\nconst util_1 = require(\"./util\");\nconst ethereum_1 = require(\"./ethereum\");\nconst sha256Stable = __importStar(require(\"@stablelib/sha256\"));\nconst uint8arrays = __importStar(require(\"uint8arrays\"));\nconst maxWordLength = 12;\nclass EosioAuthProvider {\n    constructor(provider, address) {\n        this.provider = provider;\n        this.address = address;\n        this.isAuthProvider = true;\n    }\n    async accountId() {\n        const chainId = toCAIPChainId(await this.provider.getChainId());\n        return new caip_1.AccountID({\n            address: this.address,\n            chainId: `eosio:${chainId}`,\n        });\n    }\n    async authenticate(message) {\n        const accountID = await this.accountId();\n        const signedPayload = await toSignedPayload(message, accountID, this.provider);\n        const signatureBytes = uint8arrays.fromString(signedPayload);\n        const digest = sha256Stable.hash(signatureBytes);\n        return `0x${uint8arrays.toString(digest, 'base16')}`;\n    }\n    async createLink(did) {\n        const consentMessage = util_1.getConsentMessage(did);\n        const accountID = await this.accountId();\n        const signedPayload = await toSignedPayload(consentMessage.message, accountID, this.provider);\n        return {\n            version: 1,\n            type: \"eosio\",\n            message: consentMessage.message,\n            signature: signedPayload,\n            account: accountID.toString(),\n            timestamp: consentMessage.timestamp,\n        };\n    }\n    withAddress(address) {\n        return new EosioAuthProvider(this.provider, address);\n    }\n}\nexports.EosioAuthProvider = EosioAuthProvider;\nfunction toCAIPChainId(chainId) {\n    return chainId.substr(0, 32);\n}\nfunction sanitize(str, size) {\n    return str\n        .replace(/\\s/g, \" \")\n        .replace(new RegExp(`(\\\\S{${size}})`, \"g\"), \"$1 \");\n}\nfunction toPayload(message, accountID) {\n    const { address, chainId } = accountID;\n    const payload = `${message} [For: ${address} on chain: ${chainId}]`;\n    return sanitize(payload, maxWordLength);\n}\nexports.toPayload = toPayload;\nasync function toSignedPayload(message, accountID, provider) {\n    accountID = ethereum_1.normalizeAccountId(accountID);\n    const { chainId: { reference: requestedChainId }, address, } = accountID;\n    const accountName = await provider.getAccountName();\n    const chainId = toCAIPChainId(await provider.getChainId());\n    if (chainId !== requestedChainId) {\n        throw new Error(`Provider returned a different chainId than requested [returned: ${chainId}, requested: ${requestedChainId}]`);\n    }\n    if (accountName !== address) {\n        throw new Error(`Provider returned a different account than requested [returned: ${accountName}, requested: ${address}]`);\n    }\n    const payload = toPayload(message, accountID);\n    const [key] = await provider.getKeys();\n    return provider.signArbitrary(key, payload);\n}\nexports.toSignedPayload = toSignedPayload;\n//# sourceMappingURL=eosio.js.map"]},"metadata":{},"sourceType":"script"}