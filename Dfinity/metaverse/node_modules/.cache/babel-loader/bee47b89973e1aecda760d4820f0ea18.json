{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DID = void 0;\n\nconst did_resolver_1 = require(\"did-resolver\");\n\nconst did_jwt_1 = require(\"did-jwt\");\n\nconst dag_jose_utils_1 = require(\"dag-jose-utils\");\n\nconst rpc_utils_1 = require(\"rpc-utils\");\n\nconst utils_1 = require(\"./utils\");\n\nfunction isResolver(resolver) {\n  return 'registry' in resolver && 'cache' in resolver;\n}\n\nclass DID {\n  constructor({\n    provider,\n    resolver = {},\n    resolverOptions\n  } = {}) {\n    if (provider != null) {\n      this._client = new rpc_utils_1.RPCClient(provider);\n    }\n\n    this.setResolver(resolver, resolverOptions);\n  }\n\n  get authenticated() {\n    return this._id != null;\n  }\n\n  get id() {\n    if (this._id == null) {\n      throw new Error('DID is not authenticated');\n    }\n\n    return this._id;\n  }\n\n  setProvider(provider) {\n    if (this._client == null) {\n      this._client = new rpc_utils_1.RPCClient(provider);\n    } else if (this._client.connection !== provider) {\n      throw new Error('A different provider is already set, create a new DID instance to use another provider');\n    }\n  }\n\n  setResolver(resolver, resolverOptions) {\n    this._resolver = isResolver(resolver) ? resolver : new did_resolver_1.Resolver(resolver, resolverOptions);\n  }\n\n  authenticate({\n    provider,\n    paths = [],\n    aud\n  } = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (provider != null) {\n        this.setProvider(provider);\n      }\n\n      if (this._client == null) {\n        throw new Error('No provider available');\n      }\n\n      const nonce = utils_1.randomString();\n      const jws = yield this._client.request('did_authenticate', {\n        nonce,\n        aud,\n        paths\n      });\n      const {\n        kid\n      } = yield this.verifyJWS(jws);\n      const payload = utils_1.base64urlToJSON(jws.payload);\n      if (!kid.includes(payload.did)) throw new Error('Invalid authencation response, kid mismatch');\n      if (payload.nonce !== nonce) throw new Error('Invalid authencation response, wrong nonce');\n      if (payload.aud !== aud) throw new Error('Invalid authencation response, wrong aud');\n      if (payload.exp < Date.now() / 1000) throw new Error('Invalid authencation response, expired');\n      this._id = payload.did;\n      return this._id;\n    });\n  }\n\n  createJWS(payload, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._client == null) throw new Error('No provider available');\n      if (this._id == null) throw new Error('DID is not authenticated');\n      const {\n        jws\n      } = yield this._client.request('did_createJWS', Object.assign(Object.assign({\n        did: this._id\n      }, options), {\n        payload\n      }));\n      return jws;\n    });\n  }\n\n  createDagJWS(payload, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        cid,\n        linkedBlock\n      } = yield dag_jose_utils_1.encodePayload(payload);\n      const payloadCid = utils_1.encodeBase64Url(cid.bytes);\n      Object.assign(options, {\n        linkedBlock: utils_1.encodeBase64(linkedBlock)\n      });\n      const jws = yield this.createJWS(payloadCid, options);\n      jws.link = cid;\n      return {\n        jws,\n        linkedBlock\n      };\n    });\n  }\n\n  verifyJWS(jws, options = {}) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof jws !== 'string') jws = utils_1.fromDagJWS(jws);\n      const effectiveOptions = Object.assign({\n        atTime: new Date().valueOf()\n      }, options);\n      const kid = utils_1.base64urlToJSON(jws.split('.')[0]).kid;\n      if (!kid) throw new Error('No \"kid\" found in jws');\n      const didResolutionResult = yield this.resolve(kid);\n      const nextUpdate = (_a = didResolutionResult.didDocumentMetadata) === null || _a === void 0 ? void 0 : _a.nextUpdate;\n\n      if (nextUpdate) {\n        if (effectiveOptions.atTime >= new Date(nextUpdate).valueOf()) {\n          throw new Error(`JWS was signed with a revoked DID version: ${kid}`);\n        }\n      }\n\n      const publicKeys = ((_b = didResolutionResult.didDocument) === null || _b === void 0 ? void 0 : _b.verificationMethod) || [];\n      did_jwt_1.verifyJWS(jws, publicKeys);\n      let payload;\n\n      try {\n        payload = utils_1.base64urlToJSON(jws.split('.')[1]);\n      } catch (e) {}\n\n      return {\n        kid,\n        payload,\n        didResolutionResult\n      };\n    });\n  }\n\n  createJWE(cleartext, recipients, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const encrypters = yield did_jwt_1.resolveX25519Encrypters(recipients, this._resolver);\n      return did_jwt_1.createJWE(cleartext, encrypters, options.protectedHeader, options.aad);\n    });\n  }\n\n  createDagJWE(cleartext, recipients, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.createJWE(dag_jose_utils_1.prepareCleartext(cleartext), recipients, options);\n    });\n  }\n\n  decryptJWE(jwe, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._client == null) throw new Error('No provider available');\n      if (this._id == null) throw new Error('DID is not authenticated');\n      const {\n        cleartext\n      } = yield this._client.request('did_decryptJWE', Object.assign(Object.assign({\n        did: this._id\n      }, options), {\n        jwe\n      }));\n      return utils_1.decodeBase64(cleartext);\n    });\n  }\n\n  decryptDagJWE(jwe) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const bytes = yield this.decryptJWE(jwe);\n      return dag_jose_utils_1.decodeCleartext(bytes);\n    });\n  }\n\n  resolve(didUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield this._resolver.resolve(didUrl);\n\n      if (result.didResolutionMetadata.error) {\n        const {\n          error,\n          message\n        } = result.didResolutionMetadata;\n        const maybeMessage = message ? `, ${message}` : '';\n        throw new Error(`Failed to resolve ${didUrl}: ${error}${maybeMessage}`);\n      }\n\n      return result;\n    });\n  }\n\n}\n\nexports.DID = DID;","map":{"version":3,"sources":["../src/did.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DID = void 0;\nconst did_resolver_1 = require(\"did-resolver\");\nconst did_jwt_1 = require(\"did-jwt\");\nconst dag_jose_utils_1 = require(\"dag-jose-utils\");\nconst rpc_utils_1 = require(\"rpc-utils\");\nconst utils_1 = require(\"./utils\");\nfunction isResolver(resolver) {\n    return 'registry' in resolver && 'cache' in resolver;\n}\nclass DID {\n    constructor({ provider, resolver = {}, resolverOptions } = {}) {\n        if (provider != null) {\n            this._client = new rpc_utils_1.RPCClient(provider);\n        }\n        this.setResolver(resolver, resolverOptions);\n    }\n    get authenticated() {\n        return this._id != null;\n    }\n    get id() {\n        if (this._id == null) {\n            throw new Error('DID is not authenticated');\n        }\n        return this._id;\n    }\n    setProvider(provider) {\n        if (this._client == null) {\n            this._client = new rpc_utils_1.RPCClient(provider);\n        }\n        else if (this._client.connection !== provider) {\n            throw new Error('A different provider is already set, create a new DID instance to use another provider');\n        }\n    }\n    setResolver(resolver, resolverOptions) {\n        this._resolver = isResolver(resolver) ? resolver : new did_resolver_1.Resolver(resolver, resolverOptions);\n    }\n    authenticate({ provider, paths = [], aud } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (provider != null) {\n                this.setProvider(provider);\n            }\n            if (this._client == null) {\n                throw new Error('No provider available');\n            }\n            const nonce = utils_1.randomString();\n            const jws = yield this._client.request('did_authenticate', {\n                nonce,\n                aud,\n                paths,\n            });\n            const { kid } = yield this.verifyJWS(jws);\n            const payload = utils_1.base64urlToJSON(jws.payload);\n            if (!kid.includes(payload.did))\n                throw new Error('Invalid authencation response, kid mismatch');\n            if (payload.nonce !== nonce)\n                throw new Error('Invalid authencation response, wrong nonce');\n            if (payload.aud !== aud)\n                throw new Error('Invalid authencation response, wrong aud');\n            if (payload.exp < Date.now() / 1000)\n                throw new Error('Invalid authencation response, expired');\n            this._id = payload.did;\n            return this._id;\n        });\n    }\n    createJWS(payload, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._client == null)\n                throw new Error('No provider available');\n            if (this._id == null)\n                throw new Error('DID is not authenticated');\n            const { jws } = yield this._client.request('did_createJWS', Object.assign(Object.assign({ did: this._id }, options), { payload }));\n            return jws;\n        });\n    }\n    createDagJWS(payload, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { cid, linkedBlock } = yield dag_jose_utils_1.encodePayload(payload);\n            const payloadCid = utils_1.encodeBase64Url(cid.bytes);\n            Object.assign(options, { linkedBlock: utils_1.encodeBase64(linkedBlock) });\n            const jws = yield this.createJWS(payloadCid, options);\n            jws.link = cid;\n            return { jws, linkedBlock };\n        });\n    }\n    verifyJWS(jws, options = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof jws !== 'string')\n                jws = utils_1.fromDagJWS(jws);\n            const effectiveOptions = Object.assign({ atTime: new Date().valueOf() }, options);\n            const kid = utils_1.base64urlToJSON(jws.split('.')[0]).kid;\n            if (!kid)\n                throw new Error('No \"kid\" found in jws');\n            const didResolutionResult = yield this.resolve(kid);\n            const nextUpdate = (_a = didResolutionResult.didDocumentMetadata) === null || _a === void 0 ? void 0 : _a.nextUpdate;\n            if (nextUpdate) {\n                if (effectiveOptions.atTime >= new Date(nextUpdate).valueOf()) {\n                    throw new Error(`JWS was signed with a revoked DID version: ${kid}`);\n                }\n            }\n            const publicKeys = ((_b = didResolutionResult.didDocument) === null || _b === void 0 ? void 0 : _b.verificationMethod) || [];\n            did_jwt_1.verifyJWS(jws, publicKeys);\n            let payload;\n            try {\n                payload = utils_1.base64urlToJSON(jws.split('.')[1]);\n            }\n            catch (e) {\n            }\n            return { kid, payload, didResolutionResult };\n        });\n    }\n    createJWE(cleartext, recipients, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const encrypters = yield did_jwt_1.resolveX25519Encrypters(recipients, this._resolver);\n            return did_jwt_1.createJWE(cleartext, encrypters, options.protectedHeader, options.aad);\n        });\n    }\n    createDagJWE(cleartext, recipients, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.createJWE(dag_jose_utils_1.prepareCleartext(cleartext), recipients, options);\n        });\n    }\n    decryptJWE(jwe, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._client == null)\n                throw new Error('No provider available');\n            if (this._id == null)\n                throw new Error('DID is not authenticated');\n            const { cleartext } = yield this._client.request('did_decryptJWE', Object.assign(Object.assign({ did: this._id }, options), { jwe }));\n            return utils_1.decodeBase64(cleartext);\n        });\n    }\n    decryptDagJWE(jwe) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const bytes = yield this.decryptJWE(jwe);\n            return dag_jose_utils_1.decodeCleartext(bytes);\n        });\n    }\n    resolve(didUrl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this._resolver.resolve(didUrl);\n            if (result.didResolutionMetadata.error) {\n                const { error, message } = result.didResolutionMetadata;\n                const maybeMessage = message ? `, ${message}` : '';\n                throw new Error(`Failed to resolve ${didUrl}: ${error}${maybeMessage}`);\n            }\n            return result;\n        });\n    }\n}\nexports.DID = DID;\n//# sourceMappingURL=did.js.map"]},"metadata":{},"sourceType":"script"}