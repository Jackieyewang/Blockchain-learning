{"ast":null,"code":"import { Subscription, pipe, Subscriber, Subject } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar TransportSubject = /*#__PURE__*/function (_Subject) {\n  _inheritsLoose(TransportSubject, _Subject);\n\n  function TransportSubject(source, sink) {\n    var _this;\n\n    _this = _Subject.call(this) || this;\n    _this._source = source;\n    _this._sink = sink;\n    return _this;\n  } // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore MsgOut can be different from MsgIn\n\n\n  var _proto = TransportSubject.prototype;\n\n  _proto.next = function next(message) {\n    var _this$_sink$next, _this$_sink;\n\n    (_this$_sink$next = (_this$_sink = this._sink).next) == null ? void 0 : _this$_sink$next.call(_this$_sink, message);\n  } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  ;\n\n  _proto.error = function error(err) {\n    var _this$_sink$error, _this$_sink2;\n\n    (_this$_sink$error = (_this$_sink2 = this._sink).error) == null ? void 0 : _this$_sink$error.call(_this$_sink2, err);\n  };\n\n  _proto.complete = function complete() {\n    var _this$_sink$complete, _this$_sink3;\n\n    (_this$_sink$complete = (_this$_sink3 = this._sink).complete) == null ? void 0 : _this$_sink$complete.call(_this$_sink3);\n  };\n\n  _proto._subscribe = function _subscribe(subscriber) {\n    var _this$_source$subscri;\n\n    return (_this$_source$subscri = this._source.subscribe(subscriber)) != null ? _this$_source$subscri : Subscription.EMPTY;\n  };\n\n  return TransportSubject;\n}(Subject);\n\nfunction createWrap(namespace) {\n  return function wrap(msg) {\n    return {\n      __tw: true,\n      ns: namespace,\n      msg: msg\n    };\n  };\n}\n\nfunction createUnwrap(namespace) {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  return function unwrap(input) {\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n    if (input.__tw !== true) {\n      throw new Error('Input is not a wrapped message');\n    }\n\n    if (typeof input.ns !== 'string') {\n      throw new Error(\"Invalid namespace type for wrapped message: expected a string, got \" + typeof input.ns);\n    }\n\n    if (input.ns !== namespace) {\n      throw new Error(\"Invalid namespace for wrapped message: expected \" + namespace + \", got \" + input.ns);\n    }\n\n    return input.msg;\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n  };\n}\n\nfunction createWrapper(namespace) {\n  return {\n    wrap: createWrap(namespace),\n    unwrap: createUnwrap(namespace)\n  };\n}\n\nfunction createUnwrapOperator(unwrap, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (options.throwWhenInvalid) {\n    return pipe(map(unwrap));\n  }\n\n  var onInvalid = typeof options.onInvalidInput === 'function' ? options.onInvalidInput : function onInvalid(input, error) {\n    console.warn('Invalid transport input', input, error);\n  };\n  return pipe(map(function (input) {\n    try {\n      return unwrap(input);\n    } catch (err) {\n      onInvalid(input, err);\n      return null;\n    }\n  }), filter(function (msg) {\n    return msg !== null;\n  }));\n}\n\nfunction createWrapObserver(observer, wrap) {\n  return new Subscriber(function (msg) {\n    if (msg != null) {\n      observer.next(wrap(msg));\n    }\n  });\n}\n\nfunction createWrappedTransport(transport, _ref, options) {\n  var wrap = _ref.wrap,\n      unwrap = _ref.unwrap;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var source = transport.pipe(createUnwrapOperator(unwrap, options));\n  var sink = createWrapObserver(transport, wrap);\n  return new TransportSubject(source, sink);\n}\n\nfunction createNamespacedTransport(transport, namespace, options) {\n  return createWrappedTransport(transport, createWrapper(namespace), options);\n}\n\nexport { TransportSubject, createNamespacedTransport, createUnwrap, createUnwrapOperator, createWrap, createWrapObserver, createWrappedTransport, createWrapper };","map":{"version":3,"sources":["../src/index.ts"],"names":["TransportSubject","next","error","complete","_subscribe","Subscription","createWrap","namespace","__tw","ns","msg","createUnwrap","input","createWrapper","wrap","unwrap","createUnwrapOperator","options","pipe","map","onInvalid","console","filter","createWrapObserver","observer","createWrappedTransport","transport","source","sink","createNamespacedTransport"],"mappings":"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","sourcesContent":["import { Subject, Subscriber, Subscription, pipe } from 'rxjs'\nimport type { Observable, Observer, OperatorFunction } from 'rxjs'\nimport { filter, map } from 'rxjs/operators'\n\nexport class TransportSubject<MsgIn, MsgOut = MsgIn> extends Subject<MsgIn> {\n  _source: Observable<MsgIn>\n  _sink: Observer<MsgOut>\n\n  constructor(source: Observable<MsgIn>, sink: Observer<MsgOut>) {\n    super()\n    this._source = source\n    this._sink = sink\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore MsgOut can be different from MsgIn\n  next(message: MsgOut): void {\n    this._sink.next?.(message)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  error(err: any): void {\n    this._sink.error?.(err)\n  }\n\n  complete(): void {\n    this._sink.complete?.()\n  }\n\n  _subscribe(subscriber: Subscriber<MsgIn>): Subscription {\n    return this._source.subscribe(subscriber) ?? Subscription.EMPTY\n  }\n}\n\nexport type Wrapper<MsgIn, MsgOut, WrappedOut> = {\n  wrap: (msg: MsgOut) => WrappedOut\n  unwrap: (input: any) => MsgIn\n}\n\nexport type Wrapped<Message, Namespace extends string = string> = {\n  __tw: true\n  msg: Message\n  ns: Namespace\n}\n\nexport function createWrap<MsgOut, Namespace extends string = string>(namespace: Namespace) {\n  return function wrap(msg: MsgOut): Wrapped<MsgOut, Namespace> {\n    return { __tw: true, ns: namespace, msg }\n  }\n}\n\nexport function createUnwrap<MsgIn, Namespace extends string = string>(namespace: Namespace) {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  return function unwrap(input: any): MsgIn {\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n    if (input.__tw !== true) {\n      throw new Error('Input is not a wrapped message')\n    }\n    if (typeof input.ns !== 'string') {\n      throw new Error(\n        `Invalid namespace type for wrapped message: expected a string, got ${typeof input.ns}`\n      )\n    }\n    if (input.ns !== namespace) {\n      throw new Error(\n        `Invalid namespace for wrapped message: expected ${namespace}, got ${input.ns as string}`\n      )\n    }\n    return input.msg as MsgIn\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n  }\n}\n\nexport function createWrapper<MsgIn, MsgOut = MsgIn, Namespace extends string = string>(\n  namespace: Namespace\n): Wrapper<MsgIn, MsgOut, Wrapped<MsgOut, Namespace>> {\n  return { wrap: createWrap(namespace), unwrap: createUnwrap(namespace) }\n}\n\nexport type UnwrapObservableOptions = {\n  onInvalidInput?: (input: unknown, error: Error) => void\n  throwWhenInvalid?: boolean\n}\n\nexport function createUnwrapOperator<WrappedIn, MsgIn>(\n  unwrap: (input: any) => MsgIn,\n  options: UnwrapObservableOptions = {}\n): OperatorFunction<WrappedIn, MsgIn> {\n  if (options.throwWhenInvalid) {\n    return pipe(map(unwrap))\n  }\n\n  const onInvalid =\n    typeof options.onInvalidInput === 'function'\n      ? options.onInvalidInput\n      : function onInvalid(input: unknown, error: Error) {\n          console.warn('Invalid transport input', input, error)\n        }\n  return pipe(\n    map((input) => {\n      try {\n        return unwrap(input)\n      } catch (err) {\n        onInvalid(input, err)\n        return null\n      }\n    }),\n    filter((msg): msg is MsgIn => msg !== null)\n  )\n}\n\nexport function createWrapObserver<MsgOut, WrappedOut>(\n  observer: Observer<WrappedOut>,\n  wrap: (msg: MsgOut) => WrappedOut\n): Observer<MsgOut> {\n  return new Subscriber((msg) => {\n    if (msg != null) {\n      observer.next(wrap(msg))\n    }\n  })\n}\n\nexport function createWrappedTransport<MsgIn, MsgOut, WrappedIn, WrappedOut = WrappedIn>(\n  transport: TransportSubject<WrappedIn, WrappedOut>,\n  { wrap, unwrap }: Wrapper<MsgIn, MsgOut, WrappedOut>,\n  options: UnwrapObservableOptions = {}\n): TransportSubject<MsgIn, MsgOut> {\n  const source = transport.pipe(createUnwrapOperator<WrappedIn, MsgIn>(unwrap, options))\n  const sink = createWrapObserver(transport, wrap)\n  return new TransportSubject(source, sink)\n}\n\nexport function createNamespacedTransport<MsgIn, MsgOut = MsgIn, Namespace extends string = string>(\n  transport: TransportSubject<Wrapped<MsgIn, Namespace>, Wrapped<MsgOut, Namespace>>,\n  namespace: Namespace,\n  options?: UnwrapObservableOptions\n): TransportSubject<MsgIn, MsgOut> {\n  return createWrappedTransport(transport, createWrapper(namespace), options)\n}\n"]},"metadata":{},"sourceType":"module"}